<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.0.1">Jekyll</generator>
<link href="https://zhuio.github.io/feed.xml" rel="self" type="application/atom+xml" />
<link href="https://zhuio.github.io/" rel="alternate" type="text/html" />
<updated>2017-03-28T11:22:00+08:00</updated>
<id>https://zhuio.github.io/</id>
<subtitle>朱智博，朱智博的博客，zhuio,zhuio.github.io,</subtitle>
<entry>
<title>terminal proxy</title>
<link href="https://zhuio.github.io/terminal-proxy/" rel="alternate" type="text/html" title="terminal proxy" />
<published>2017-03-28T11:11:00+08:00</published>
<updated>2017-03-28T11:11:00+08:00</updated>
<id>https://zhuio.github.io/terminal-proxy</id>
<content type="html" xml:base="https://zhuio.github.io/terminal-proxy/">&lt;h2 id=&quot;proxychainssocks5&quot;&gt;利用proxychains在终端使用socks5代理&lt;/h2&gt;

&lt;h3 id=&quot;proxychains&quot;&gt;1.proxychains安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/rofl0r/proxychains-ng.git
cd proxychains-ng
./configure
make &amp;amp;&amp;amp; make install
cp ./src/proxychains.conf /etc/proxychains.conf
cd .. &amp;amp;&amp;amp; rm -rf proxychains-ng
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;brew install proxychains-ng&lt;/code&gt;安装。&lt;/p&gt;

&lt;h3 id=&quot;proxychains-1&quot;&gt;2.编辑proxychains配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1


vim /etc/proxychains.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;socks4-127001-9095&quot;&gt;3.将&lt;code class=&quot;highlighter-rouge&quot;&gt;socks4 127.0.0.1 9095&lt;/code&gt;改为&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1


socks5 127.0.0.1 1080
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ps: 默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;socks4 127.0.0.1 9095&lt;/code&gt;是tor代理，而&lt;code class=&quot;highlighter-rouge&quot;&gt;socks5 127.0.0.1 1080&lt;/code&gt;是shadowsocks的代理。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxychains.conf&lt;/code&gt;文件说明了代理配置格式,如下,这里根据自己使用的代理来配置就行了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ProxyList format
94#       type  ip  port  [user pass]
95#       (values separated by &#39;tab&#39; or &#39;blank&#39;)
96#
97#       only numeric ipv4 addresses are valid
98#
99#
100#        Examples:
101#
102#       socks5  192.168.67.78   1080    lamer   secret
103#       http    192.168.89.3    8080    justu   hidden
104#       socks4  192.168.1.49    1080
105#       http    192.168.39.93   8080
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;4.使用方法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;在需要代理的命令前加上 proxychains4 ，如：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxychains4 wget http://xxx.com/xxx.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5.测试方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl ip.gs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
<category term="proxychains4" />
<category term="ubuntu" />
<category term="terminal" />
<summary>利用proxychains在终端使用socks5代理</summary>
</entry>
<entry>
<title>Ubuntu常用命令</title>
<link href="https://zhuio.github.io/ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="alternate" type="text/html" title="Ubuntu常用命令" />
<published>2017-03-08T01:43:00+08:00</published>
<updated>2017-03-08T01:43:00+08:00</updated>
<id>https://zhuio.github.io/ubuntu常用命令</id>
<content type="html" xml:base="https://zhuio.github.io/ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">&lt;h1 id=&quot;ubuntu&quot;&gt;Ubuntu常用命令整理&lt;/h1&gt;

&lt;p&gt;ubuntu命令很多，要熟练运用所有的命令有一定的难度。但大部分情况下，我们只要掌握常用的那些就够了，剩下的在必要时查资料即可。
下面就对我们平时常用的ubuntu命令进行简单介绍。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1、文件/文件夹管理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; 列出当前目录下的所有文件（不显示隐藏文件）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -a&lt;/code&gt; 列出当前目录下的所有文件（显示隐藏文件）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -l&lt;/code&gt;列出当前目录下所有文件的详细信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~&lt;/code&gt;进入用户主目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ..&lt;/code&gt; 回到上一级目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd -&lt;/code&gt;返回进入此目录之前所在的目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir dirname&lt;/code&gt; 新建目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rmdir dirname&lt;/code&gt; 删除空目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rm filename&lt;/code&gt; 删除文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rm -rf dirname&lt;/code&gt; 删除非空目录及其包含的所有文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mv file1 file2&lt;/code&gt;将文件1重命名为文件2&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mv file1 dir1&lt;/code&gt; 将文件1移动到目录1中&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find 路径 -name “字符串”&lt;/code&gt; 查找路径所在范围内满足字符串匹配的文件和目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2、程序安装与卸载&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; 程序安装与卸载命令的标志，需要管理员权限&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt; 安装指定程序，举例：&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt; 卸载指定的程序，一般最好加上“–purge”执行清除
式卸载；并在程序名称后添加*号。举例：&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get remove --purge nvidia*&lt;/code&gt;  卸载 nvidia 的驱动及其配置文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; 更新本地软件源文件，需要管理员权限，举例：&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get update&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3、打包/解压&lt;/h2&gt;

&lt;p&gt;这里需要先解释几个参数。
参数含义参数含义-c建立压缩档案-z有gzip属性的-t查看内容-j有bz2属性的-u更新原压缩包中的文件-Z有compress属性的-x解压-v显示所有过程-r向压缩归档文件末尾追加文件-O将文件解开到标准输出
上表左边五个参数是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。右边五个参数是根据需要在压缩或解压时可选的。
下面进行举例说明。
&lt;strong&gt;压缩&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -cvf jpg.tar *.jpg&lt;/code&gt; 将目录里所有jpg文件打包成tar.jpg&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -czf jpg.tar.gz *.jpg&lt;/code&gt;   将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -cjf jpg.tar.bz2 *.jpg&lt;/code&gt; 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -cZf jpg.tar.Z *.jpg&lt;/code&gt;   将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rar a jpg.rar *.jpg&lt;/code&gt; rar格式的压缩，需要先下载rar for linux&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zip jpg.zip *.jpg&lt;/code&gt; zip格式的压缩，需要先下载zip for linux&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;解压&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xvf file.tar&lt;/code&gt; 解压 tar包&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xzvf file.tar.gz&lt;/code&gt; 解压tar.gz&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xjvf file.tar.bz2&lt;/code&gt;   解压 tar.bz2&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xZvf file.tar.Z&lt;/code&gt;   解压tar.Z&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unrar e file.rar&lt;/code&gt; 解压rar&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unzip file.zip&lt;/code&gt; 解压zip&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;
.tar 用 tar -xvf 解压
.gz 用 gzip -d或者gunzip 解压
.tar.gz和.tgz 用 tar -xzf 解压
.bz2 用 bzip2 -d或者用bunzip2 解压
 .tar.bz2用tar -xjf 解压
.Z 用 uncompress 解压
.tar.Z 用tar -xZf 解压
.rar 用 unrar e解压
.zip 用 unzip 解压&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;4、用户管理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo useradd username&lt;/code&gt; 创建一个新的用户username&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo passwd username&lt;/code&gt; 设置用户username的密码&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo groupadd groupname&lt;/code&gt; 创建一个新的组groupname&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo usermod -g groupname username&lt;/code&gt; 把用户username加入到组groupname中&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chown username:groupname dirname&lt;/code&gt; 将指定文件的拥有者改为指定的用户或组&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;5、系统管理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uname -a&lt;/code&gt; 查看内核版本&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cat /etc/issue&lt;/code&gt; 查看ubuntu版本&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo fdisk -l&lt;/code&gt; 查看磁盘信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;df -h&lt;/code&gt; 查看硬盘剩余空间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free -m&lt;/code&gt; 查看当前的内存使用情况&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ps -A&lt;/code&gt; 查看当前有哪些进程&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill 进程号&lt;/code&gt;或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;killall 进程名&lt;/code&gt; 杀死进程&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -9 进程号&lt;/code&gt; 强制杀死进程&lt;/li&gt;
&lt;/ul&gt;
</content>
<category term="Ubuntu" />
<summary>Ubuntu常用命令整理</summary>
</entry>
<entry>
<title>youtube-dl</title>
<link href="https://zhuio.github.io/youtube-dl/" rel="alternate" type="text/html" title="youtube-dl" />
<published>2017-02-20T23:48:00+08:00</published>
<updated>2017-02-20T23:48:00+08:00</updated>
<id>https://zhuio.github.io/youtube-dl</id>
<content type="html" xml:base="https://zhuio.github.io/youtube-dl/">&lt;h1 id=&quot;youtube&quot;&gt;下载YouTube视频&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查看视频所有类型,只看不下载
  youtube-dl -F [url]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者
    youtube-dl –list-formats [url]&lt;/p&gt;

&lt;p&gt;这是一个列清单参数，执行后并不会下载视频，但能知道这个目标视频都有哪些格式存在，这样就可以有选择的下载啦！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-5c8620972c0957c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看YouTube视频所有类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载指定质量的视频和音频并自动合并
  youtube-dl -f [format code] [url]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过上一步获取到了所有视频格式的清单，最左边一列就是编号对应着不同的格式.
由于YouTube的1080p及以上的分辨率都是音视频分离的,所以我们需要分别下载视频和音频,可以使用137+140这样的组合.
如果系统中安装了ffmpeg的话, youtube-dl 会自动合并下下好的视频和音频, 然后自动删除单独的音视频文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-5fabdc8817bb3135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载1080p的视频&lt;/p&gt;

&lt;p&gt;-
下载字幕&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;youtubd-dl --write-sub [url] //这样会下载一个vtt格式的英文字幕和mkv格式的1080p视频下来

youtube-dl --write-sub --skip-download [url] //下载单独的vtt字幕文件,而不会下载视频

youtube-dl --write-sub --all-subs [url] //下载所有语言的字幕(如果有的话)

youtube-dl --write-auto-sub [url] //下载自动生成的字幕(YouTube only)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-191ff153e45eea04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载字幕和视频&lt;/p&gt;

&lt;p&gt;-
下载视频列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;youtube-dl -f [format code] [palylist_url] //这种方式可以下载制定清晰度的mp4视频

youtube-dl [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式

youtube-dl -cit [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式

youtube-dl --yes-playlist [url] //当链接为视频列表,则下载该列表视频,跟上面的一样,可能是mkv或者webm格式
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;vimeo&quot;&gt;下载Vimeo视频&lt;/h1&gt;

&lt;p&gt;Vimeo的视频下载起来比较方便,因为没有分离,可以直接下载1080p带音频的视频
命令与下载YouTube的基本一致;下面贴几张图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-4e1b9f4b18e94700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解查看Vimeo视频所有类型&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-5720dba2d2ab972e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接下载Vimeo最高质量视频&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;youtube-dl支持的网站很多,大家可以从作者整理的&lt;a href=&quot;https://rg3.github.io/youtube-dl/supportedsites.html&quot;&gt;这个列表&lt;/a&gt;里查看支持的网站(不过由于有的网站接口改变,可能当初支持的网站现在不能很好的支持了),如果您要下载的视频网站现在不能用youtube-dl下载的,不妨试试另外一个同样基于Python开发的下载工具You-Get,我将在下一篇文章中介绍,希望大家喜欢~&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;youtube-dl官网：&lt;a href=&quot;https://yt-dl.org/&quot;&gt;https://yt-dl.org/&lt;/a&gt;
GitHub项目：&lt;a href=&quot;https://github.com/rg3/youtube-dl/&quot;&gt;https://github.com/rg3/youtube-dl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
<category term="youtube" />
<summary>下载YouTube视频</summary>
</entry>
<entry>
<title>ubuntu terminal trick</title>
<link href="https://zhuio.github.io/ubuntu-terminal-trick/" rel="alternate" type="text/html" title="ubuntu terminal trick" />
<published>2017-02-20T21:49:00+08:00</published>
<updated>2017-02-20T21:49:00+08:00</updated>
<id>https://zhuio.github.io/ubuntu-terminal-trick</id>
<content type="html" xml:base="https://zhuio.github.io/ubuntu-terminal-trick/">&lt;h4 id=&quot;section&quot;&gt;一、快捷键&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shift&amp;amp;#43;Ctrl&amp;amp;#43;T:新建标签页

Shift&amp;amp;#43;Ctrl&amp;amp;#43;W:关闭标签页

Ctrl&amp;amp;#43;PageUp:前一标签页

Ctrl&amp;amp;#43;PageDown:后一标签页

Shift&amp;amp;#43;Ctrl&amp;amp;#43;PageUp:标签页左移

Shift&amp;amp;#43;Ctrl&amp;amp;#43;PageDown:标签页右移

Alt&amp;amp;#43;1:切换到标签页1

Alt&amp;amp;#43;2:切换到标签页2

Alt&amp;amp;#43;3:切换到标签页3


Shift&amp;amp;#43;Ctrl&amp;amp;#43;N:新建窗口

Shift&amp;amp;#43;Ctrl&amp;amp;#43;Q:关闭终端


终端中的复制／粘贴:

Shift&amp;amp;#43;Ctrl&amp;amp;#43;C:复制

Shift&amp;amp;#43;Ctrl&amp;amp;#43;V:粘贴


终端改变大小：

F11：全屏

Ctrl&amp;amp;#43;plus:放大

Ctrl&amp;amp;#43;minus:减小

Ctrl&amp;amp;#43;0:原始大小
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二、组合键&lt;/h4&gt;

&lt;p&gt;1、在终端显示时间使用命令date&lt;/p&gt;

&lt;p&gt;如果想让时间显示为一定大格式，可以使用带参数带date&lt;/p&gt;

&lt;p&gt;如，date +%Y/%m/%d就会显示形如2010/7/30的形式&lt;/p&gt;

&lt;p&gt;date +%H:%M 会显示11:35&lt;/p&gt;

&lt;p&gt;2、显示日历：cal&lt;/p&gt;

&lt;p&gt;1）直接输入显示的是当前月份带日历&lt;/p&gt;

&lt;p&gt;2）也可以显示某一年的日历cal 2010,也就是cal ［年］&lt;/p&gt;

&lt;p&gt;3）总带来说cal的语法格式如下：&lt;/p&gt;

&lt;p&gt;cal [month] [year]&lt;/p&gt;

&lt;p&gt;所以还可以显示置顶月份的日历，如 2010年8月的&lt;/p&gt;

&lt;p&gt;cal  2010&lt;/p&gt;

&lt;p&gt;3、简单的计算器：bc&lt;/p&gt;

&lt;p&gt;在输入bc后会显示版本号，然后就可以输入相应的指令了。&lt;/p&gt;

&lt;p&gt;运算符： 除了加减乘除以外，还有^指数，%余数运算。&lt;/p&gt;

&lt;p&gt;》但在默认时，是不保留小数位的，想要保留小数位，需要输入命令scale=number以指定小数位数。&lt;/p&gt;

&lt;p&gt;4、Tab 按键&lt;/p&gt;

&lt;p&gt;不用多说，这事Linxu最棒带功能之一。具有［命令补全］和［档案补全］的功能。可以避免我们打错指令或文件名称！&lt;/p&gt;

&lt;p&gt;5、Ctrl + c 组合键&lt;/p&gt;

&lt;p&gt;如果输入错误的指令或参数，有时候这个指令或程序会在系统下一直不停的运行。这时可以这个组合键以“中断目前程序”。&lt;/p&gt;

&lt;p&gt;6、Ctrl + d 组合键。&lt;/p&gt;

&lt;p&gt;这个组合键有“End of File，EOF”或“End of Input”的意思。 即［键盘输入结束］。相当于‘exit’。&lt;/p&gt;

&lt;p&gt;如想退出终端就可以直接按此组合键。&lt;/p&gt;

&lt;h4 id=&quot;linux&quot;&gt;三、linux图形界面切换到字符界面&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;X-Window图形界面和字符界面自由切换&lt;/p&gt;

    &lt;p&gt;一、图形界面切换到字符界面&lt;/p&gt;

    &lt;p&gt;①在X-Window图形操作界面中按“Alt+Ctrl+Fn（n=1~6）”就可以进入Console字符操作界面。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这就意味着你可以同时拥有X-Window加上6个Console字符操作界面。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;②如果不行，就加上Backspace键：（同时按住Alt+Ctrl，在按一下Backspace并松开，再按Fn）&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在X-Window图形操作界面中按“Alt&amp;amp;#43;Ctrl&amp;amp;#43;Backspace&amp;amp;#43;Fn（n=1~6）”就可以进入Console字符操作界面。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;二、字符界面切换到图像界面&lt;/p&gt;

    &lt;p&gt;①按“Alt+Ctrl+F7”或者“Alt+Ctrl+Backspace+F7”即可。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  这时Linux默认打开7个屏幕，编号为tty1~tty7。X-Window启动后，占用的是tty7号屏幕，tty1~tty6仍为字符界面屏幕。也就是说，用“Alt&amp;amp;#43;Ctrl&amp;amp;#43;Fn”组合键即可实现字符界面与X Window界面的快速切换。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.开机进入字符界面设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;为了在Linux开机启动时直接进入Console字符界面，我们可以编辑/etc/inittab文件。

找到id:5: initdefault:这一行，将它改为id:3:initdefault:后重新启动系统即可。

我们看到，简简单单地将5改为3，就能实现启动时进入X-Window图形操作界面或Console字符界面的转换，这是因为Linux操作系统有六种不同的运行级（run level），在不同的运行级下，系统有着不同的状态，这六种运行级分别为：

  0 ：停机（记住不要把initdefault 设置为0，因为这样会使Linux无法启动 ）

 1：单用户模式，就像Win9X下的安全模式。

 2：多用户，但是没有 NFS 。

 3：完全多用户模式，标准的运行级。

 4：一般不用，在一些特殊情况下可以用它来做一些事情。

 5：X11，即进到 X-Window 系统。

 6：重新启动 （记住不要把initdefault 设置为6，因为这样会使Linux不断地重新启动）。


 其中运行级3就是我们要进入的标准Console字符界面模式。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;linux-1&quot;&gt;四、Linux终端字符界面显示乱码解决方法&lt;/h4&gt;

&lt;p&gt;方法一：配置SSH工具&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SecureCRT中文版配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[全局选项]→[默认会话]→[编辑默认设置]→[终端]→[外观]→[字体]→[新宋体 10pt CHINESE_GB2312]→[字符编码 UTF-8]&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Putty配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[window]→[Appearance]→[Font settings]→[Change]→[Fixedsys CHINESE_GB2312]&lt;/p&gt;

&lt;p&gt;[window]→[Appearance]→[Translation]→[Received data assumed to be in which character set]→[Use font encoding UTF-8]&lt;/p&gt;

&lt;p&gt;如果经常使用,把这些设置保存在session里面。&lt;/p&gt;

&lt;p&gt;打开putty，登录成功后，在shell中输入:export LC_ALL=’zh_CN.utf8’&lt;/p&gt;

&lt;p&gt;方法二：配置系统&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;console终端乱码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在/etc/profile文件的最后一行添加如下内容：&lt;/p&gt;

&lt;p&gt;export LC_ALL=”zh_CN.GB18030”&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;xwindow终端乱码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在/etc/sysconfig/i18n文件的最后一行添加如下内容：&lt;/p&gt;

&lt;p&gt;export LC_ALL=”zh_CN.GB18030”&lt;/p&gt;

&lt;p&gt;vi /etc/sysconfig/i18n&lt;/p&gt;

&lt;p&gt;将内容改为&lt;/p&gt;

&lt;p&gt;LANG=”zh_CN.GB18030”&lt;/p&gt;

&lt;p&gt;LANGUAGE=”zh_CN.GB18030:zh_CN.GB2312:zh_CN”&lt;/p&gt;

&lt;p&gt;SUPPORTED=”zh_CN.GB18030:zh_CN:zh:en_US.UTF-8:en_US:en”&lt;/p&gt;

&lt;p&gt;SYSFONT=”lat0-sun16”&lt;/p&gt;

&lt;p&gt;之后重启机器，这样中文在SSH,telnet终端就可以正常显示了。&lt;/p&gt;

&lt;p&gt;注意：若操作系统语言是英文，显示中文字符为乱码时&lt;/p&gt;

&lt;p&gt;编辑/etc/sysconfig/i18n，修改为如下内容：&lt;/p&gt;

&lt;p&gt;LANG=”en_US”&lt;/p&gt;

&lt;p&gt;SUPPORTED=”en_US.UTF-8:en_US:en”&lt;/p&gt;

&lt;p&gt;SYSFONT=”latarcyrheb-sun16”&lt;/p&gt;
</content>
<category term="ubuntu" />
<summary>一、快捷键</summary>
</entry>
<entry>
<title>pip requirements</title>
<link href="https://zhuio.github.io/pip-requirements/" rel="alternate" type="text/html" title="pip requirements" />
<published>2017-02-19T18:32:00+08:00</published>
<updated>2017-02-19T18:32:00+08:00</updated>
<id>https://zhuio.github.io/pip-requirements</id>
<content type="html" xml:base="https://zhuio.github.io/pip-requirements/">&lt;h1 id=&quot;requirementstxt&quot;&gt;如何自动生成和安装requirements.txt依赖&lt;/h1&gt;

&lt;p&gt;在查看别人的Python项目时，经常会看到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;requirements.txt&lt;/code&gt;文件，里面记录了当前程序的所有依赖包及其精确版本号。这个文件有点类似与Rails的&lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt;。其作用是用来在另一台PC上重新构建项目所需要的运行环境依赖。&lt;/p&gt;

&lt;p&gt;requirements.txt可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt;命令自动生成和安装&lt;/p&gt;

&lt;h3 id=&quot;requirementstxt-1&quot;&gt;生成requirements.txt文件&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;requirementstxt-2&quot;&gt;安装requirements.txt依赖&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pip install -r requirements.txt&lt;/code&gt;&lt;/p&gt;
</content>
<category term="python" />
<category term="pip" />
<summary>如何自动生成和安装requirements.txt依赖</summary>
</entry>
<entry>
<title>shadowsocks锐速</title>
<link href="https://zhuio.github.io/shadowsocks%E9%94%90%E9%80%9F/" rel="alternate" type="text/html" title="shadowsocks锐速" />
<published>2017-02-18T21:35:00+08:00</published>
<updated>2017-02-18T21:35:00+08:00</updated>
<id>https://zhuio.github.io/shadowsocks锐速</id>
<content type="html" xml:base="https://zhuio.github.io/shadowsocks%E9%94%90%E9%80%9F/">&lt;h2 id=&quot;section&quot;&gt;更换内核&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-3.10.0-229.1.2.el7.x86_64.rpm --force
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;锐速加速&lt;/h2&gt;

&lt;p&gt;查看&lt;a href=&quot;https://www.91yun.org/wp-content/plugins/91yun-serverspeeder/systemlist.html&quot;&gt;linux支持内核列表&lt;/a&gt;**&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;uname -a&lt;/code&gt;命令来查询内核版本，例如返回的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux ss 3.8.0-35-generic&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;3.8.0-35-generic&lt;/code&gt;就是内核版本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这里顺便说一下linode VPS仅支持debian7系统，在选择内核时请选择3.14.5-x86_64-linode42版本，这个版本才能安装锐速。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后检查你的VPS是什么虚拟化技术，锐速不支持OpenVZ的（而大部分很便宜的VPS都是OpenVZ）&lt;/p&gt;

&lt;p&gt;我们只需要安装&lt;strong&gt;vitr-what&lt;/strong&gt;就能知道VPS的虚拟化技术是什么了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cent OS 系统：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install virt-what -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Debian/Ubuntu 系统：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install virt-what -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装后执行下面这个命令，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;virt-what
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行后会显示你的VPS虚拟化技术，如果不是OpenVZ，那么可以继续下面的安装步骤了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;安装开心版锐速&lt;/h2&gt;

&lt;p&gt;确定自己的内核版本在支持列表里，并且虚拟化技术非OpenVZ，就可以使用以下命令一键安装了。&lt;/p&gt;

&lt;p&gt;为了备份和存档，这里我收集了几个锐速开心版的一键安装脚本，&lt;strong&gt;大家优先使用第一个脚本！&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;amp;&amp;amp; bash serverspeeder-all.sh
# 注意！！建议使用第一个代码来安装，下面的几个都是备用的，功能都一样，不需要重复执行，只需要执行第一行代码就行了，每一行代码都是独立的。
————
curl -s http://f.ylnote.com/f/install -o install;chmod 775 install;./install
wget -O - http://file.idc.wiki/get.php?serverSpeeder | bash &amp;amp;&amp;amp; bash serverSpeeder_setup.sh
————
# 上面三个不区分系统。下面这四个区分系统
————
# Debian7 64位
wget o0o.re/rs&amp;amp;&amp;amp;sh rs
# Centos6 64位
wget o0o.re/rscentos&amp;amp;&amp;amp;sh rscentos
# centos7 64位
wget o0o.re/rscentos7&amp;amp;&amp;amp;sh rscentos7
# Ubuntu14 64位
wget o0o.re/rsu&amp;amp;&amp;amp;sh rsu
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本会自动检测你的VPS是否可以按照开心版锐速，如果可以就会提示你参数或者直接安装完成，参数设置直接回车默认即可。&lt;/p&gt;

&lt;p&gt;最后两项输入&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;开机自动启动锐速，&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;立刻启动锐速。（这个参数设置一般情况下都是不会出现的。）&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;https://doub.io/wp-content/plugins/wp-images-lazy-loading/images/grey.gif&quot; alt=&quot;&quot; /&gt;![](https://img.mlkxs.com/ruisu-jc1.1.jpg?imageView2/1/w/2000/q/100&lt;/td&gt;
      &lt;td&gt;watermark/1/image/aHR0cDovLzd4ajh0NC5jb20xLnowLmdsYi5jbG91ZGRuLmNvbS9zaHVpeWluLnBuZw==/dissolve/80/gravity/SouthEast/dx/10/dy/10)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-3&quot;&gt;卸载开心版锐速&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chattr -i /serverspeeder/etc/apx* &amp;amp;&amp;amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;锐速开心版功能：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;如果内核完全匹配就会自动下载安装。&lt;/li&gt;
  &lt;li&gt;如果没有完全匹配的内核，会在界面提示可选内核，可以手动选个最接近的尝试&lt;/li&gt;
  &lt;li&gt;自动下载授权文件&lt;/li&gt;
  &lt;li&gt;自动修改配置文件&lt;/li&gt;
  &lt;li&gt;已chattr +i /serverspeeder/etc/apx*禁止修改配置文件，可以不用加hosts了&lt;/li&gt;
  &lt;li&gt;目前只支持CentOS，ubuntu和debian。如果有其他系统支持，可以到http://www.91yun.org/serverspeeder91yun手动下载其他系统的安装包&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;开启高级算法&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Tip：开心版锐速默认都启动高级算法了，所以可以忽略下面的步骤。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一些KVM/XEN的VPS上支持高级算法，所以我们可以修改锐速的3个参数来开启，&lt;code class=&quot;highlighter-rouge&quot;&gt;vi /serverspeeder/etc/config&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rsc=&quot;1&quot; #RSC网卡驱动模式  
gso=&quot;1&quot;
maxmode=&quot;1&quot; #最大传输模式
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;使用命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#重启锐速
/serverspeeder/bin/serverSpeeder.sh restart
#启动锐速
/serverspeeder/bin/serverSpeeder.sh start
#停止锐速
/serverspeeder/bin/serverSpeeder.sh stop
#查看锐速运行情况
/serverspeeder/bin/serverSpeeder.sh status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-7&quot;&gt;删除锐速&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#脚本删除，如果不行就用下面的强制删除
./serverSpeederInstaller.sh uninstall
强制删除
rm -rf /serverspeeder
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;第一个开心版锐速脚本来自：&lt;a href=&quot;https://www.91yun.org/archives/683&quot;&gt;https://www.91yun.org/archives/683&lt;/a&gt;&lt;/p&gt;
</content>
<category term="shadowsocks" />
<summary>更换内核</summary>
</entry>
<entry>
<title>flask框架5</title>
<link href="https://zhuio.github.io/flask%E6%A1%86%E6%9E%B65/" rel="alternate" type="text/html" title="flask框架5" />
<published>2017-02-12T15:37:00+08:00</published>
<updated>2017-02-12T15:37:00+08:00</updated>
<id>https://zhuio.github.io/flask框架5</id>
<content type="html" xml:base="https://zhuio.github.io/flask%E6%A1%86%E6%9E%B65/">&lt;h2 id=&quot;flask&quot;&gt;动态基于用户的内容Flask教程&lt;/h2&gt;

&lt;p&gt;虽然我们可以使用装饰器来包围访问控制的函数，但我们也可以使用我们的Jinja模板逻辑来控制视图。例如，现在，当我们登录我们的网站时，我们仍然在右上角有一个“登录”按钮。&lt;/p&gt;

&lt;p&gt;我们应该真的让登录按钮消失，与注册按钮一样，然后添加一个“注销”按钮。&lt;/p&gt;

&lt;p&gt;我们实际上可以在我们的HTML文件中处理所有这些，所以让我们访问我们的header.html文件。&lt;/p&gt;

&lt;p&gt;找到与navbar相关联的代码，然后替换为一些逻辑：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	  &amp;lt;ul class=&quot;nav navbar-nav navbar-right&quot;&amp;gt;
		    &amp;lt;div style=&quot;margin-right: 10px; margin-left: 15px; margin-top: 5px; margin-bottom: 5px;&quot;  class=&quot;container-fluid&quot;&amp;gt;
			&amp;lt;h5&amp;gt;
				&amp;amp;#123;% if session.logged_in %}
				&amp;lt;a href=&quot;/support-donate/&quot;&amp;gt; &amp;lt;span class=&quot;glyphicon glyphicon-heart&quot;&amp;gt;&amp;lt;/span&amp;gt; Support   &amp;lt;/a&amp;gt;
				&amp;lt;a href=&quot;/logout/&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-log-out&quot;&amp;gt;&amp;lt;/span&amp;gt; Logout   &amp;lt;/a&amp;gt;
				&amp;amp;#123;% else %}
				&amp;lt;a href=&quot;/support-donate/&quot;&amp;gt; &amp;lt;span class=&quot;glyphicon glyphicon-heart&quot;&amp;gt;&amp;lt;/span&amp;gt; Support   &amp;lt;/a&amp;gt;
				&amp;lt;a href=&quot;/login/&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-log-in&quot;&amp;gt;&amp;lt;/span&amp;gt; Login   &amp;lt;/a&amp;gt;
				&amp;lt;a href=&quot;/register/&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-pencil&quot;&amp;gt;&amp;lt;/span&amp;gt; Sign up&amp;lt;/a&amp;gt;
				&amp;amp;#123;% endif %}
			&amp;lt;/div&amp;gt;

			&amp;lt;/h5&amp;gt;
		  &amp;lt;/div&amp;gt;
      &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的两件事：我们显然能够引用会话，我们不需要在我们的模板中“导入”它。这样的逻辑在你的HTML可以抛出一个循环的默认标签识别/突出显示！&lt;/p&gt;

&lt;p&gt;Jinja模板基本上有一个“从烧瓶进口*”在幕后。您可以在模板中引用任何Flask内容，而无需将其导入模板或脚本。&lt;/p&gt;

&lt;p&gt;当你构建这样的HTML逻辑，特别是当它影响用户看到什么，你可能会发现它破坏了自然的突出显示，你的编辑器可能会标记的东西，如标签没有关闭等。使用你更好的判断。有时，如果内容足够厚，并且是一种if / else类似上面，我将删除每个块，一次一个，并检查以确保一切连接正确。&lt;/p&gt;

&lt;p&gt;不管什么，但是，它可以是混乱。注意它，特别是如果你让你的编辑器自动关闭或移动标签。&lt;/p&gt;
</content>
<category term="flask" />
<summary>动态基于用户的内容Flask教程</summary>
</entry>
<entry>
<title>flask框架4</title>
<link href="https://zhuio.github.io/flask%E6%A1%86%E6%9E%B64/" rel="alternate" type="text/html" title="flask框架4" />
<published>2017-02-12T15:36:00+08:00</published>
<updated>2017-02-12T15:36:00+08:00</updated>
<id>https://zhuio.github.io/flask框架4</id>
<content type="html" xml:base="https://zhuio.github.io/flask%E6%A1%86%E6%9E%B64/">&lt;h2 id=&quot;flask---loginrequiredflask&quot;&gt;Flask装饰器 - Login_Required页面Flask教程&lt;/h2&gt;

&lt;p&gt;现在我们可以让用户注册和登录，我们也允许他们注销。这是有一点意义，不让用户注销，除非他们登录！&lt;/p&gt;

&lt;p&gt;您还可能会发现您想要保护各种页面，例如管理页面，或者您有订阅者内容或其他受保护或付费内容。&lt;/p&gt;

&lt;p&gt;你可以使用包装函数。人们倾向于避开包装函数和装饰器，因为它们可能是混乱的。但是，看看你，你一直在使用他们这一次！Flask使用它们进行URL路由。让我们展示如何使我们自己的！这其实很简单！&lt;/p&gt;

&lt;p&gt;首先，我们向我们的__init__.py文件添加一个login_required函数：&lt;/p&gt;

&lt;p&gt;{% highlight css %}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def login_required(f):
    @wraps(f)
    def wrap( *args, **kwargs):
        if &#39;logged_in&#39; in session:
            return f(*args, **kwargs)
        else:
            flash(&quot;You need to login first&quot;)
            return redirect(url_for(&#39;login_page&#39;))

    return wrap {% endhighlight %}    		
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里，我们定义函数，其中参数是f，这是约定的事实，它包装一个函数。然后，我们定义包装器。&lt;/p&gt;

&lt;p&gt;我们的包装器很简单，只是简单地检查用户在会话中是否有“logged_in”。如果是这样，伟大。如果没有，他们会收到一条Flash消息和重定向到登录页面。&lt;/p&gt;

&lt;p&gt;现在我们有了包装器函数，我们准备好将它应用到任何我们想要的登录。例如，我们可以将其应用于我们的注销页面，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.route(&quot;/logout/&quot;)
@login_required
def logout():
    session.clear()
    flash(&quot;You have been logged out!&quot;)
    gc.collect()
    return redirect(url_for(&#39;dashboard&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很简单，在app.route包装器的下面，我们还添加了另一个包装器，它是login_required包装器。现在，为了甚至得到注销函数，用户必须首先尝试访问顶部包装器中的URL，然后他们还需要满足下一个包装器的条件，然后他们可以最终到达logout（）函数！&lt;/p&gt;
</content>
<category term="flask" />
<summary>Flask装饰器 - Login_Required页面Flask教程</summary>
</entry>
<entry>
<title>flask框架3</title>
<link href="https://zhuio.github.io/flask%E6%A1%86%E6%9E%B63/" rel="alternate" type="text/html" title="flask框架3" />
<published>2017-02-12T15:34:00+08:00</published>
<updated>2017-02-12T15:34:00+08:00</updated>
<id>https://zhuio.github.io/flask框架3</id>
<content type="html" xml:base="https://zhuio.github.io/flask%E6%A1%86%E6%9E%B63/">&lt;h2 id=&quot;flask&quot;&gt;Flask用户登录系统教程&lt;/h2&gt;

&lt;p&gt;它让我们相当多，但在这里我们是：登录页面！如果你还没有，那么你应该注册一些用户，并记住其中之一，以测试我们的登录页面，当我们完成。&lt;/p&gt;

&lt;p&gt;我们已经有了登录模板，我们可以保留，但现在验证过程需要验证我们的数据库中的用户，而不是硬编码的管理员用户。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Part of __init__.py file&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.route(&#39;/login/&#39;, methods=[&quot;GET&quot;,&quot;POST&quot;])
def login_page():
    error = &#39;&#39;
    try:
        c, conn = connection()
        if request.method == &quot;POST&quot;:

            data = c.execute(&quot;SELECT * FROM users WHERE username = (%s)&quot;,
                             thwart(request.form[&#39;username&#39;]))

            data = c.fetchone()[2]

            if sha256_crypt.verify(request.form[&#39;password&#39;], data):
                session[&#39;logged_in&#39;] = True
                session[&#39;username&#39;] = request.form[&#39;username&#39;]

                flash(&quot;You are now logged in&quot;)
                return redirect(url_for(&quot;dashboard&quot;))

            else:
                error = &quot;Invalid credentials, try again.&quot;

        gc.collect()

        return render_template(&quot;login.html&quot;, error=error)

    except Exception as e:
        #flash(e)
        error = &quot;Invalid credentials, try again.&quot;
        return render_template(&quot;login.html&quot;, error = error)  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这里，我们使用我们写的连接文件来连接到数据库（dbconnect.py），它有一个名为connection的函数。&lt;/p&gt;

&lt;p&gt;我们对POST方法进行与前面相同的检查。如果是这样，我们将查询数据库以查看该人员输入的用户名是否在数据库中，而不是忘记使用thwart来防止SQL注入。&lt;/p&gt;

&lt;p&gt;接下来，如果用户名存在，我们然后将尝试的用户名与我们记录的散列密码进行比较，验证存储的散列的来源是否与用户尝试的密码相同。&lt;/p&gt;

&lt;p&gt;如果是这样，那么我们通过Flask的会话功能登录用户，然后我们将它们发送到仪表板，因为他们都完成了登录页面。&lt;/p&gt;

&lt;p&gt;如果出现任何问题，我们给出的错误只是“凭据无效，请重试”。您可以提供自定义错误，例如该用户名不存在或密码错误，但有人试图破解您的网站或用户名可以使用它的优势，知道他们错了什么。&lt;/p&gt;
</content>
<category term="flask" />
<category term="hash" />
<summary>Flask用户登录系统教程</summary>
</entry>
<entry>
<title>flask框架2</title>
<link href="https://zhuio.github.io/flask%E6%A1%86%E6%9E%B62/" rel="alternate" type="text/html" title="flask框架2" />
<published>2017-02-12T15:33:00+08:00</published>
<updated>2017-02-12T15:33:00+08:00</updated>
<id>https://zhuio.github.io/flask框架2</id>
<content type="html" xml:base="https://zhuio.github.io/flask%E6%A1%86%E6%9E%B62/">&lt;h2 id=&quot;flask&quot;&gt;Flask教程的密码哈希&lt;/h2&gt;

&lt;p&gt;虽然我们已经将密码哈希加入我们的注册页面，我想花一些时间来讨论实际发生的事情。也许你最终使用另一种语言，或者也许passlib不支持你在未来使用的Python版本。正因为如此，你应该至少在高层了解它是如何工作的。&lt;/p&gt;

&lt;p&gt;它不仅对安全实践很重要，它也只是很酷的工作原理！&lt;/p&gt;

&lt;p&gt;首先，你可能会理解为什么对密码进行加密很重要。如果您的数据库存储纯文本密码，至少您将自己查看密码，因此任何有权访问您的服务器的人都可以看到密码。在一个完美的世界中，没有人会侵犯用户的隐私，但这个世界并不完美。不仅如果你使用虚拟专用服务器，或者共享主机，那么为你工作的人可能窃取用户密码，黑客可能，甚至是你的服务器的主机。&lt;/p&gt;

&lt;p&gt;那么，我们如何掩盖密码？遮掩原始文本很容易，我们可以对一个随机的算法做到这一点。问题是，使用密码，我们实际上需要能够验证用户将来输入作为原始密码。&lt;/p&gt;

&lt;p&gt;采取的更原始的措施之一是简单的密码哈希。这是一个哈希函数应用于用户输入的内容，该哈希是作为密码存储的内容。&lt;/p&gt;

&lt;p&gt;这里有一个简单的哈希脚本来说明这一点，你可以运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import hashlib
password = &#39;pa$$w0rd&#39;
h = hashlib.md5(password.encode())
print(h.hexdigest())


	导入hashlib，设置示例密码，创建哈希对象，打印哈希：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6c9b8b27dea1ddb845f96aa2567c6754&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以工作相当不错。如果你刚刚在数据库中看到了哈希，你不知道这是什么意思。但是，出现以下问题：运行脚本两次，或五次。你会发现每次的输出是相同的。最初，考虑到验证，你可能认为这不是一个要求吗？我们还能如何实现验证？&lt;/p&gt;

&lt;p&gt;这里的问题是人们创建了大量的哈希表，特别是称为哈希查找表，在那里你可以搜索哈希，然后找到相应的明文密码。你也可以自己创建一个，只需为字符组合生成哈希。生成表需要更长的时间。这些表是大的，但不是太大，不能存储在你的笔记本电脑或上网本。&lt;/p&gt;

&lt;p&gt;我们需要的是一种生成唯一哈希的方法，但是通过询问两个哈希是否来自同一个输入，尽管它们是非常不同的哈希，仍然找到一种验证哈希的方法。&lt;/p&gt;

&lt;p&gt;然而，在到达之前，人们提出了一个更简单的解决方案：为什么不放置一个秘密模式的文本到每个输入的密码，只有我们的服务器知道。这就是所谓的“盐析”。&lt;/p&gt;

&lt;p&gt;盐渍，虽然仍然使用，最初开始很简单。这里有一个例子说明如何盐化工作，建立我们最后的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import hashlib

user_entered_password = &#39;pa$$w0rd&#39;
salt = &quot;5gz&quot;
db_password = user_entered_password+salt
h = hashlib.md5(db_password.encode())
print(h.hexdigest())
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这里，唯一的主要区别是我们只有一个盐，我们追加到最后。然后，任何时候用户输入他们的密码，我们添加salt，哈希，然后比较这些哈希。
&lt;code class=&quot;highlighter-rouge&quot;&gt;de6e389819bdaa9e0ca60bb52cabccae&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在，盐可以在任何地方添加。也许是在中间的输入，也许在开始，也许在结束。你可以在开始时有一个盐，另一个在密码的中间，另一个在最后甚至。&lt;/p&gt;

&lt;p&gt;这是很好，但有固有的风险，仍然，这里是为什么：&lt;/p&gt;

&lt;p&gt;对于相同的密码，哈希始终相同。这意味着如果有人破解你生成的盐，那么他们现在通过生成哈希表破解了所有密码。这又可以进行大量的处理，但这绝不是今天的标准所无法达到的。&lt;/p&gt;

&lt;p&gt;加密的一句话是，你不能依赖于安全的保密性。对加密的一个很好的测试是问自己：“如果有人发现我的加密方法，我的安全性是否受损？在许多情况下，例如用密码，对此的答案是“是的！这是一个问题。考虑有人访问您的数据库的许多原因也意味着他们有权访问您的源代码。这意味着有人可以找到你的盐。从这里，打破加密密码的整个数据库是相对快速的工作。&lt;/p&gt;

&lt;p&gt;我们想要的是一种生成唯一哈希的方法，它们的源可以容易地验证，但是暴力强制将需要每个密码的强制强制，而不是整个数据库的暴力强制。让我们带上passlib的大枪。&lt;/p&gt;

&lt;p&gt;如果你没有passlib，你可能不会，因为它不是标准库的一部分，做一个快速：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pip install passlib&lt;/code&gt;
or…
&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install python-passlib&lt;/code&gt;
Once you have passlib, let’s play!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from passlib.hash import sha256_crypt

password = sha256_crypt.encrypt(&quot;password&quot;)
password2 = sha256_crypt.encrypt(&quot;password&quot;)

print(password)
print(password2)

print(sha256_crypt.verify(&quot;password&quot;, password))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我们引入passlib的哈希能力，并使用SHA256作为算法。SHA256本质上优于md5，但是在上面的例子中你可以用“sha256”替换“md5”，看到输出的哈希值保持不变，只是稍长一些。&lt;/p&gt;

&lt;p&gt;接下来，我们显示我们使用sha256_crypt从passlib哈希“密码”两次。一次到密码的变量，再一次到password2。&lt;/p&gt;

&lt;p&gt;然后我们输出两者的哈希，注意他们是不同的。&lt;/p&gt;

&lt;p&gt;最后，我们验证两个单独的哈希值来自同一个源。&lt;/p&gt;

&lt;p&gt;果然，布尔环响了，我们有一个匹配！&lt;/p&gt;

&lt;p&gt;现在，我们有一个很好的方法来保护用户密码，同时仍然能够在用户登录时验证用户。&lt;/p&gt;

&lt;p&gt;现在，考虑黑客违反我们的服务器并获得对我们的源代码和我们的数据库的要求。他们可以看到一切，但现在什么？&lt;/p&gt;

&lt;p&gt;现在，他们将不得不通过暴力破解密码，与以前一样，只是现在它是一次一个密码。Yikes。他们可以做的是获取他们的密码字典（通常是可能的密码的大量列表），生成一个散列，然后尝试验证这个散列对数据库中的所有密码，通过迭代每个并运行sha256_crypt.verify他们真/假反应。然而，这个过程是非常麻烦的，并且结果是缓慢的。这将需要很长时间，并且没有办法预先准备这里。你可能会想，他们不能通过生成SHA256哈希在高级准备？不，因为sha256_crypt也使用独特的盐。&lt;/p&gt;

&lt;p&gt;在我写这篇文章的时候，这个方法没有已知的弱点。&lt;/p&gt;

&lt;p&gt;现在，我想强调使用上面的“方法”。在方法和方法的应用之间存在主要区别。&lt;/p&gt;

&lt;p&gt;另一个加密和安全性的格言通常如下：&lt;/p&gt;

&lt;p&gt;“你可以在地球上拥有最坚固，最不可穿透的加固门保护一个房间，但如果墙仍然薄弱，那就没有好处。&lt;/p&gt;

&lt;p&gt;忘记墙壁，天花板，甚至地面都很简单。&lt;/p&gt;

&lt;p&gt;考虑你写了一个程序的逻辑多少次，认为它是坚实的，然后遇到一个错误，并“当然！你会不断犯错误，你可能知道你做了很多。有安全性，这些错误通常是未经检查，未经测试。尝试你最好的想像一个黑客，但永远记住&lt;em&gt;每个&lt;/em&gt;系统，连接到万维网，是可以攻击。只接受它，并在这个前提下工作。&lt;/p&gt;

&lt;p&gt;接受passlib可能有缺陷，有一天，或者已经有人知道SHA256的缺陷。此外，大量的密码加密系统被黑客与服务器访问极其简单：&lt;/p&gt;

&lt;p&gt;如果黑客获得对你的服务器的访问，并发现你的数据库被安全加密，他们可以做一些简单的事情，在登录表单上创建一个日志记录功能，它只是简单地保存用户键入的字段，到文本文件，或在别处传输数据。这显然不像一次获得整个数据库那么大，但是这种事情发生了。&lt;/p&gt;

&lt;p&gt;很多人也对2FA（双因素身份验证）等事情给予了很大的信任。我讨厌爆破你的泡沫，但是，虽然这种方法使很多道理，这种方法的应用程序，你，客户端和你使用的网站非常重要。&lt;/p&gt;

&lt;p&gt;作为一个开发人员，我已经设置了2FA几次。有很多选项，您可以选择安装2FA时，可以增加或阻碍安全。一个特别的，非常受欢迎的比特币钱包网站，例如，重新使用公共密钥为您的2FA。我发现这个，当我换手机。其结果是，有人可以暂时访问您的手机，访问您的帐户，重新验证2FA，您会发现在您的设备上没有任何更改。他们正在回收生成代码的公钥。现在他们只是等待你存了一大笔钱，然后他们带你。你永远不会知道你甚至是脆弱的。如果黑客也可以伪造你的会话cookie，这是另一种方式，他们可以做到这一点，他们甚至不需要你的代码。虚拟会话很难，但仍然可能。这就是为什么网站通常要求您在对帐户进行安全更改时重新输入密码。这个流行的比特币钱包网站？不，不需要重新输入您的密码。&lt;/p&gt;

&lt;p&gt;尼斯安全的门，但薄弱的墙壁。&lt;/p&gt;

&lt;p&gt;2FA错误的另一个很好的例子是当人们通过像Google一样使用2FA。很好，但如果你有你的2FA设置与谷歌验证器的Gmail帐户也不受2FA保护，你拧紧了。&lt;/p&gt;

&lt;p&gt;大门，薄弱的墙壁。&lt;/p&gt;

&lt;p&gt;最后，在让你感到脆弱之前，我将解决所有企业和服务器的最薄弱点：&lt;/p&gt;

&lt;p&gt;运行他们的人。&lt;/p&gt;

&lt;p&gt;最弱的环节总是人民。无论是因为他们犯错误，还是因为他们可以很容易地进行社交工程，人们通常是主要目标，或者至少是漏洞的原因。&lt;/p&gt;

&lt;p&gt;我甚至不能计算我看到有多少网站被黑客入侵，因为有人提出了一个管理员，并能够获得访问。这听起来很蠢，但这个骗局很容易跌倒，特别是考虑到我们生活在今天的世界，开发人员分散，通常不是所有的本地。我个人是成功版本的受害者，我有网站的开发人员是黑客，我有无尽的尝试。这是黑客做的，他们黑客。他们不断尝试，最终他们可以通过。你的工作是使它尽可能具有挑战性。&lt;/p&gt;

&lt;p&gt;这就像大多数犯罪。大多数犯罪是机会犯罪，你的工作不是最慢，最胖，最可怕的孩子从熊跑。&lt;/p&gt;
</content>
<category term="flask" />
<summary>Flask教程的密码哈希</summary>
</entry>
</feed>
