<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator>
<link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
<link href="http://localhost:4000/" rel="alternate" type="text/html" />
<updated>2017-04-03T19:18:33+08:00</updated>
<id>http://localhost:4000/</id>
<subtitle>朱智博，朱智博的博客，zhuio,zhuio.github.io,</subtitle>
<entry>
<title>用python写脚本</title>
<link href="http://localhost:4000/%E7%94%A8python%E5%86%99%E8%84%9A%E6%9C%AC/" rel="alternate" type="text/html" title="用python写脚本" />
<published>2017-04-03T19:10:00+08:00</published>
<updated>2017-04-03T19:10:00+08:00</updated>
<id>http://localhost:4000/用python写脚本</id>
<content type="html" xml:base="http://localhost:4000/%E7%94%A8python%E5%86%99%E8%84%9A%E6%9C%AC/">&lt;h3 id=&quot;python&quot;&gt;python写脚本&lt;/h3&gt;

&lt;p&gt;那，python可以做shell脚本吗？ 首先介绍一个函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;os.system(command)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个函数可以调用shell运行命令行&lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;并且返回它的返回值。试一下在python的解释器里输入&lt;code class=&quot;highlighter-rouge&quot;&gt;os.system(&quot;ls -l&quot;)&lt;/code&gt;，就可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;列出了当前目录下的文件。可以说，通过这个函数，python就拥有了shell的所有能力。呵呵。。不过，通常这条命令不需要用到。因为shell常用的那些命令在python中通常有对应而且同样简洁的写法。&lt;/p&gt;

&lt;p&gt;shell中最常用的是ls命令，python对应的写法是：&lt;code class=&quot;highlighter-rouge&quot;&gt;os.listdir(dirname)&lt;/code&gt;，这个函数返回字符串列表，里面是所有的文件名，不过不包含&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;..&lt;/code&gt;。如果要遍历整个目录的话就会比较复杂一点。我们等下再说吧。先在解释器里试一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;os.listdir(&quot;/&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就像这样，接下去所有命令都可以在python的解释器里直接运行观看结果。&lt;/p&gt;

&lt;p&gt;对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;cp&lt;/code&gt;命令的是：&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.copy(src,dest)&lt;/code&gt;，这个函数有两个参数，参数&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;是指源文件的名字，参数dest则是目标文件或者目标目录的名字。 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;dest&lt;/code&gt;是一个目录名，就会在那个目录下创建一个相同名字的文件。与&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.copy&lt;/code&gt;函数相类似的是&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.copy2(src,dest)，不过&lt;/code&gt;copy2`还会复制最后存取时间和最后更新时间。&lt;/p&gt;

&lt;p&gt;不过，shell的&lt;code class=&quot;highlighter-rouge&quot;&gt;cp&lt;/code&gt;命令还可以复制目录，python的&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.copy&lt;/code&gt;却不行，第一个参数只能是一个文件。这怎么办？其实，python还有个&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.copytree(src, dst [,symlinks])&lt;/code&gt; 。参数多了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;symlinks&lt;/code&gt;，它是一个布尔值，如果是True的话就创建符号链接。&lt;/p&gt;

&lt;p&gt;移动或者重命名文件和目录呢？估计被聪明的朋友猜到了，&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.move(src,dst)&lt;/code&gt;，呵呵。。与&lt;code class=&quot;highlighter-rouge&quot;&gt;mv&lt;/code&gt;命令类似，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;dst&lt;/code&gt;在同一个文件系统上，&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.move&lt;/code&gt;只是简单改一下名字，如果src和dst在不同的文件系统上，&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.move&lt;/code&gt;会先把&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;复制到&lt;code class=&quot;highlighter-rouge&quot;&gt;ds&lt;/code&gt;t，然后删除&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;文件。看到现在，大多数朋友应该已经对python的能力有点眉目了，接下来我就列个表，介绍一下其它的函数：&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.chdir(dirname)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把当前工作目录切换到dirname下&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.getcwd()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回当前的工作目录路径&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.chroot(dirname)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把dirname作为进程的根目录。和*nix下的&lt;code class=&quot;highlighter-rouge&quot;&gt;chroot&lt;/code&gt;命令类似&lt;/p&gt;

&lt;p&gt;-
os.chmod(path,mode)&lt;/p&gt;

&lt;p&gt;更改&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;的权限位。&lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt;可以是以下值(使用&lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;)的组合：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;os.S_ISUIDos.S_ISGIDos.S_ENFMTos.S_ISVTXos.S_IREADos.S_IWRITEos.S_IEXECos.S_IRWXUos.S_IRUSRos.S_IWUSRos.S_IXUSRos.S_IRWXGos.S_IRGRPos.S_IWGRPos.S_IXGRPos.S_IRWXOos.S_IROTHos.S_IWOTHos.S_IXOTH
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体它们是什么含义，就不仔细说了，基本上就是&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;代表读,&lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt;代表写，&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;代表执行权限。&lt;code class=&quot;highlighter-rouge&quot;&gt;USR&lt;/code&gt;代表用户，&lt;code class=&quot;highlighter-rouge&quot;&gt;GRP&lt;/code&gt;代表组，&lt;code class=&quot;highlighter-rouge&quot;&gt;OTH&lt;/code&gt;代表其它。&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.chown(path,uid,gid)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;改变文件的属主。uid和gid为-1的时候不改变原来的属主。&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.link(src,dst)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建硬连接&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.mkdir(path,[mode])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建目录。&lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt;的意义参见&lt;code class=&quot;highlighter-rouge&quot;&gt;os.chmod()&lt;/code&gt;，默认是0777&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.makedirs(path,[mode])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;os.mkdir()&lt;/code&gt;类似，不过会先创建不存在的父目录。&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.readlink(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回path这个符号链接所指向的路径&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.remove(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除文件，不能用于删除目录&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.rmdir(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除文件夹，不能用于删除文件&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.symlink(src,dst)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建符号链接&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil.rmtree(path[,ignore_errors[,onerror]])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除文件夹&lt;/p&gt;

&lt;p&gt;介绍了这么多，其实只要查一下&lt;code class=&quot;highlighter-rouge&quot;&gt;os&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil&lt;/code&gt;两个模块的文档就有了，呵呵。。真正编写shell脚本的时候还需要注意：&lt;/p&gt;

&lt;p&gt;1.
环境变量。python的环境变量保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;os.environ&lt;/code&gt;这个字典里，可以用普通字典的方法修改它，使用system启动其它程序的时候会自动被继承。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;os.environ[&quot;fish&quot;]=&quot;nothing&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过也要注意，环境变量的值只能是字符串。和shell有些不同的是，python没有&lt;code class=&quot;highlighter-rouge&quot;&gt;export&lt;/code&gt;环境变量这个概念。为什么没有呢？因为python没有必要有:-)&lt;/p&gt;

&lt;p&gt;1.
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path&lt;/code&gt;这个模块里包含了很多关于路径名处理的函数。在shell里路径名处理好像不是很重要，但是在python里经常需要用到。最常用的两个是分离和合并目录名和文件名：&lt;/p&gt;

&lt;p&gt;2.
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.split(path) -&amp;gt; (dirname,basename)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数会把一个路径分离为两部分，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.split(&quot;/foo/bar.dat&quot;)&lt;/code&gt;会返回&lt;code class=&quot;highlighter-rouge&quot;&gt;(&quot;/foo&quot;,&quot;bar.dat&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.join(dirname,basename)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数会把目录名和文件名组合成一个完整的路径名，比如：os.path.join(“/foo”,”bar.dat”)会返回”/foo/bar.dat”。这个函数和os.path.split()刚好相反。&lt;/p&gt;

&lt;p&gt;还有这些函数：&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.abspath(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把path转成绝对路径&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.expanduser(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把path中包含的&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;~&quot;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;~user&quot;&lt;/code&gt;转换成用户目录&lt;/p&gt;

&lt;p&gt;-
os.path.expandvars(path)&lt;/p&gt;

&lt;p&gt;根据环境变量的值替换path中包含的”$name”和”${name}”，比如环境变量FISH=nothing，那os.path.expandvars(“$FISH/abc”)会返回”nothing/abc”&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.normpath(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;去掉path中包含的”.”和”..”&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.splitext(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把path分离成基本名和扩展名。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.splitext(&quot;/foo/bar.tar.bz2&quot;)&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;('/foo/bar.tar', '.bz2')&lt;/code&gt;。要注意它和&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.split()&lt;/code&gt;的区别&lt;/p&gt;

&lt;p&gt;-
在&lt;code class=&quot;highlighter-rouge&quot;&gt;os&lt;/code&gt;模块有一个很好用的函数叫&lt;code class=&quot;highlighter-rouge&quot;&gt;os.stat()&lt;/code&gt;没有介绍，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path&lt;/code&gt;模块里包含了一组和它具有同样功能的函数，但是名字更好记一点。&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.exists(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;判断文件或者目录是否存在&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.isfile(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;判断path所指向的是否是一个普通文件，而不是目录&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.isdir(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;判断path所指向的是否是一个目录，而不是普通文件&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.islink(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;判断path所指向的是否是一个符号链接&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.ismount(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;判断path所指向的是否是一个挂接点(mount point)&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.getatime(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回path所指向的文件或者目录的最后存取时间。&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.getmtime(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回path所指向的文件或者目录的最后修改时间&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.getctime(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回path所指向的文件的创建时间&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.getsize(path)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回path所指向的文件的大小&lt;/p&gt;

&lt;p&gt;-
应用python编写shell脚本经常要用到&lt;code class=&quot;highlighter-rouge&quot;&gt;os&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;shutil&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;glob&lt;/code&gt;(正则表达式的文件名),&lt;code class=&quot;highlighter-rouge&quot;&gt;tempfile&lt;/code&gt;(临时文件),&lt;code class=&quot;highlighter-rouge&quot;&gt;pwd&lt;/code&gt;(操作&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt;文件),&lt;code class=&quot;highlighter-rouge&quot;&gt;grp&lt;/code&gt;(操作&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/group&lt;/code&gt;文件),&lt;code class=&quot;highlighter-rouge&quot;&gt;commands&lt;/code&gt;(取得一个命令的输出)。前面两个已经基本上介绍完了，后面几个很简单，看一下文档就可以了。&lt;/p&gt;

&lt;p&gt;-
&lt;code class=&quot;highlighter-rouge&quot;&gt;sys.argv&lt;/code&gt;是一个列表，保存了python程序的命令行参数。其中&lt;code class=&quot;highlighter-rouge&quot;&gt;sys.argv[0]&lt;/code&gt;是程序本身的名字。&lt;/p&gt;

&lt;p&gt;不能光说不练，接下来我们就编写一个用于复制文件的简单脚本。前两天叫我写脚本的同事有个几万个文件的目录，他想复制这些文件到其它的目录，又不能直接复制目录本身。他试了一下&lt;code class=&quot;highlighter-rouge&quot;&gt;cp src/* dest/&lt;/code&gt;结果报了一个命令行太长的错误，让我帮他写一个脚本。操起python来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;importsys,os.path,shutilforfinos.listdir(sys.argv[1]):shutil.copy(os.path.join(sys.argv[1],f),sys.argv[2])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再试一下linuxapp版里的帖子——把一个文件夹下的所有文件重命名成&lt;code class=&quot;highlighter-rouge&quot;&gt;10001～10999&lt;/code&gt;。可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;importos.path,sysdirname=sys.argv[1]i=10001forfinos.listdir(dirname):src=os.path.join(dirname,f)ifos.path.isdir(src):continueos.rename(src,str(i))i+=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
<category term="python" />
<summary>python写脚本</summary>
</entry>
<entry>
<title>django note</title>
<link href="http://localhost:4000/django-note/" rel="alternate" type="text/html" title="django note" />
<published>2017-04-03T17:28:00+08:00</published>
<updated>2017-04-03T17:28:00+08:00</updated>
<id>http://localhost:4000/django-note</id>
<content type="html" xml:base="http://localhost:4000/django-note/">
</content>
</entry>
<entry>
<title>terminal proxy</title>
<link href="http://localhost:4000/terminal-proxy/" rel="alternate" type="text/html" title="terminal proxy" />
<published>2017-03-28T11:11:00+08:00</published>
<updated>2017-03-28T11:11:00+08:00</updated>
<id>http://localhost:4000/terminal-proxy</id>
<content type="html" xml:base="http://localhost:4000/terminal-proxy/">&lt;h2 id=&quot;proxychainssocks5&quot;&gt;利用proxychains在终端使用socks5代理&lt;/h2&gt;

&lt;h3 id=&quot;proxychains&quot;&gt;1.proxychains安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/rofl0r/proxychains-ng.git
cd proxychains-ng
./configure
make &amp;amp;&amp;amp; make install
cp ./src/proxychains.conf /etc/proxychains.conf
cd .. &amp;amp;&amp;amp; rm -rf proxychains-ng
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;brew install proxychains-ng&lt;/code&gt;安装。&lt;/p&gt;

&lt;h3 id=&quot;proxychains-1&quot;&gt;2.编辑proxychains配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim /etc/proxychains.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;socks4-127001-9095&quot;&gt;3.将&lt;code class=&quot;highlighter-rouge&quot;&gt;socks4 127.0.0.1 9095&lt;/code&gt;改为&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;socks5 127.0.0.1 1080
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ps: 默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;socks4 127.0.0.1 9095&lt;/code&gt;是tor代理，而&lt;code class=&quot;highlighter-rouge&quot;&gt;socks5 127.0.0.1 1080&lt;/code&gt;是shadowsocks的代理。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxychains.conf&lt;/code&gt;文件说明了代理配置格式,如下,这里根据自己使用的代理来配置就行了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ProxyList format
94#       type  ip  port  [user pass]
95#       (values separated by 'tab' or 'blank')
96#
97#       only numeric ipv4 addresses are valid
98#
99#
100#        Examples:
101#
102#       socks5  192.168.67.78   1080    lamer   secret
103#       http    192.168.89.3    8080    justu   hidden
104#       socks4  192.168.1.49    1080
105#       http    192.168.39.93   8080
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;4.使用方法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;在需要代理的命令前加上 proxychains4 ，如：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxychains4 wget http://xxx.com/xxx.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5.测试方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl ip.gs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
<category term="proxychains4" />
<category term="ubuntu" />
<category term="terminal" />
<summary>利用proxychains在终端使用socks5代理</summary>
</entry>
<entry>
<title>Ubuntu常用命令</title>
<link href="http://localhost:4000/ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="alternate" type="text/html" title="Ubuntu常用命令" />
<published>2017-03-08T01:43:00+08:00</published>
<updated>2017-03-08T01:43:00+08:00</updated>
<id>http://localhost:4000/ubuntu常用命令</id>
<content type="html" xml:base="http://localhost:4000/ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">&lt;h1 id=&quot;ubuntu&quot;&gt;Ubuntu常用命令整理&lt;/h1&gt;

&lt;p&gt;ubuntu命令很多，要熟练运用所有的命令有一定的难度。但大部分情况下，我们只要掌握常用的那些就够了，剩下的在必要时查资料即可。
下面就对我们平时常用的ubuntu命令进行简单介绍。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1、文件/文件夹管理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; 列出当前目录下的所有文件（不显示隐藏文件）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -a&lt;/code&gt; 列出当前目录下的所有文件（显示隐藏文件）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -l&lt;/code&gt;列出当前目录下所有文件的详细信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~&lt;/code&gt;进入用户主目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ..&lt;/code&gt; 回到上一级目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd -&lt;/code&gt;返回进入此目录之前所在的目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir dirname&lt;/code&gt; 新建目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rmdir dirname&lt;/code&gt; 删除空目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rm filename&lt;/code&gt; 删除文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rm -rf dirname&lt;/code&gt; 删除非空目录及其包含的所有文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mv file1 file2&lt;/code&gt;将文件1重命名为文件2&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mv file1 dir1&lt;/code&gt; 将文件1移动到目录1中&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find 路径 -name “字符串”&lt;/code&gt; 查找路径所在范围内满足字符串匹配的文件和目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2、程序安装与卸载&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; 程序安装与卸载命令的标志，需要管理员权限&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt; 安装指定程序，举例：&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt; 卸载指定的程序，一般最好加上“–purge”执行清除
式卸载；并在程序名称后添加*号。举例：&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get remove --purge nvidia*&lt;/code&gt;  卸载 nvidia 的驱动及其配置文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; 更新本地软件源文件，需要管理员权限，举例：&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get update&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3、打包/解压&lt;/h2&gt;

&lt;p&gt;这里需要先解释几个参数。
参数含义参数含义-c建立压缩档案-z有gzip属性的-t查看内容-j有bz2属性的-u更新原压缩包中的文件-Z有compress属性的-x解压-v显示所有过程-r向压缩归档文件末尾追加文件-O将文件解开到标准输出
上表左边五个参数是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。右边五个参数是根据需要在压缩或解压时可选的。
下面进行举例说明。
&lt;strong&gt;压缩&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -cvf jpg.tar *.jpg&lt;/code&gt; 将目录里所有jpg文件打包成tar.jpg&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -czf jpg.tar.gz *.jpg&lt;/code&gt;   将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -cjf jpg.tar.bz2 *.jpg&lt;/code&gt; 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -cZf jpg.tar.Z *.jpg&lt;/code&gt;   将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rar a jpg.rar *.jpg&lt;/code&gt; rar格式的压缩，需要先下载rar for linux&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zip jpg.zip *.jpg&lt;/code&gt; zip格式的压缩，需要先下载zip for linux&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;解压&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xvf file.tar&lt;/code&gt; 解压 tar包&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xzvf file.tar.gz&lt;/code&gt; 解压tar.gz&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xjvf file.tar.bz2&lt;/code&gt;   解压 tar.bz2&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xZvf file.tar.Z&lt;/code&gt;   解压tar.Z&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unrar e file.rar&lt;/code&gt; 解压rar&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unzip file.zip&lt;/code&gt; 解压zip&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;
.tar 用 tar -xvf 解压
.gz 用 gzip -d或者gunzip 解压
.tar.gz和.tgz 用 tar -xzf 解压
.bz2 用 bzip2 -d或者用bunzip2 解压
 .tar.bz2用tar -xjf 解压
.Z 用 uncompress 解压
.tar.Z 用tar -xZf 解压
.rar 用 unrar e解压
.zip 用 unzip 解压&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;4、用户管理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo useradd username&lt;/code&gt; 创建一个新的用户username&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo passwd username&lt;/code&gt; 设置用户username的密码&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo groupadd groupname&lt;/code&gt; 创建一个新的组groupname&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo usermod -g groupname username&lt;/code&gt; 把用户username加入到组groupname中&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chown username:groupname dirname&lt;/code&gt; 将指定文件的拥有者改为指定的用户或组&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;5、系统管理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uname -a&lt;/code&gt; 查看内核版本&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cat /etc/issue&lt;/code&gt; 查看ubuntu版本&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo fdisk -l&lt;/code&gt; 查看磁盘信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;df -h&lt;/code&gt; 查看硬盘剩余空间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free -m&lt;/code&gt; 查看当前的内存使用情况&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ps -A&lt;/code&gt; 查看当前有哪些进程&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill 进程号&lt;/code&gt;或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;killall 进程名&lt;/code&gt; 杀死进程&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -9 进程号&lt;/code&gt; 强制杀死进程&lt;/li&gt;
&lt;/ul&gt;
</content>
<category term="Ubuntu" />
<summary>Ubuntu常用命令整理</summary>
</entry>
<entry>
<title>youtube-dl</title>
<link href="http://localhost:4000/youtube-dl/" rel="alternate" type="text/html" title="youtube-dl" />
<published>2017-02-20T23:48:00+08:00</published>
<updated>2017-02-20T23:48:00+08:00</updated>
<id>http://localhost:4000/youtube-dl</id>
<content type="html" xml:base="http://localhost:4000/youtube-dl/">&lt;h1 id=&quot;youtube&quot;&gt;下载YouTube视频&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;查看视频所有类型,只看不下载
  youtube-dl -F [url]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者
    youtube-dl –list-formats [url]&lt;/p&gt;

&lt;p&gt;这是一个列清单参数，执行后并不会下载视频，但能知道这个目标视频都有哪些格式存在，这样就可以有选择的下载啦！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-5c8620972c0957c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看YouTube视频所有类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载指定质量的视频和音频并自动合并
  youtube-dl -f [format code] [url]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过上一步获取到了所有视频格式的清单，最左边一列就是编号对应着不同的格式.
由于YouTube的1080p及以上的分辨率都是音视频分离的,所以我们需要分别下载视频和音频,可以使用137+140这样的组合.
如果系统中安装了ffmpeg的话, youtube-dl 会自动合并下下好的视频和音频, 然后自动删除单独的音视频文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-5fabdc8817bb3135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载1080p的视频&lt;/p&gt;

&lt;p&gt;-
下载字幕&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;youtubd-dl --write-sub [url] //这样会下载一个vtt格式的英文字幕和mkv格式的1080p视频下来

youtube-dl --write-sub --skip-download [url] //下载单独的vtt字幕文件,而不会下载视频

youtube-dl --write-sub --all-subs [url] //下载所有语言的字幕(如果有的话)

youtube-dl --write-auto-sub [url] //下载自动生成的字幕(YouTube only)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-191ff153e45eea04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载字幕和视频&lt;/p&gt;

&lt;p&gt;-
下载视频列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;youtube-dl -f [format code] [palylist_url] //这种方式可以下载制定清晰度的mp4视频

youtube-dl [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式

youtube-dl -cit [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式

youtube-dl --yes-playlist [url] //当链接为视频列表,则下载该列表视频,跟上面的一样,可能是mkv或者webm格式
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;vimeo&quot;&gt;下载Vimeo视频&lt;/h1&gt;

&lt;p&gt;Vimeo的视频下载起来比较方便,因为没有分离,可以直接下载1080p带音频的视频
命令与下载YouTube的基本一致;下面贴几张图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-4e1b9f4b18e94700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解查看Vimeo视频所有类型&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1294473-5720dba2d2ab972e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接下载Vimeo最高质量视频&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;youtube-dl支持的网站很多,大家可以从作者整理的&lt;a href=&quot;https://rg3.github.io/youtube-dl/supportedsites.html&quot;&gt;这个列表&lt;/a&gt;里查看支持的网站(不过由于有的网站接口改变,可能当初支持的网站现在不能很好的支持了),如果您要下载的视频网站现在不能用youtube-dl下载的,不妨试试另外一个同样基于Python开发的下载工具You-Get,我将在下一篇文章中介绍,希望大家喜欢~&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;youtube-dl官网：&lt;a href=&quot;https://yt-dl.org/&quot;&gt;https://yt-dl.org/&lt;/a&gt;
GitHub项目：&lt;a href=&quot;https://github.com/rg3/youtube-dl/&quot;&gt;https://github.com/rg3/youtube-dl/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
<category term="youtube" />
<summary>下载YouTube视频</summary>
</entry>
<entry>
<title>ubuntu terminal trick</title>
<link href="http://localhost:4000/ubuntu-terminal-trick/" rel="alternate" type="text/html" title="ubuntu terminal trick" />
<published>2017-02-20T21:49:00+08:00</published>
<updated>2017-02-20T21:49:00+08:00</updated>
<id>http://localhost:4000/ubuntu-terminal-trick</id>
<content type="html" xml:base="http://localhost:4000/ubuntu-terminal-trick/">&lt;h4 id=&quot;section&quot;&gt;一、快捷键&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shift&amp;amp;#43;Ctrl&amp;amp;#43;T:新建标签页

Shift&amp;amp;#43;Ctrl&amp;amp;#43;W:关闭标签页

Ctrl&amp;amp;#43;PageUp:前一标签页

Ctrl&amp;amp;#43;PageDown:后一标签页

Shift&amp;amp;#43;Ctrl&amp;amp;#43;PageUp:标签页左移

Shift&amp;amp;#43;Ctrl&amp;amp;#43;PageDown:标签页右移

Alt&amp;amp;#43;1:切换到标签页1

Alt&amp;amp;#43;2:切换到标签页2

Alt&amp;amp;#43;3:切换到标签页3


Shift&amp;amp;#43;Ctrl&amp;amp;#43;N:新建窗口

Shift&amp;amp;#43;Ctrl&amp;amp;#43;Q:关闭终端


终端中的复制／粘贴:

Shift&amp;amp;#43;Ctrl&amp;amp;#43;C:复制

Shift&amp;amp;#43;Ctrl&amp;amp;#43;V:粘贴


终端改变大小：

F11：全屏

Ctrl&amp;amp;#43;plus:放大

Ctrl&amp;amp;#43;minus:减小

Ctrl&amp;amp;#43;0:原始大小
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二、组合键&lt;/h4&gt;

&lt;p&gt;1、在终端显示时间使用命令date&lt;/p&gt;

&lt;p&gt;如果想让时间显示为一定大格式，可以使用带参数带date&lt;/p&gt;

&lt;p&gt;如，date +%Y/%m/%d就会显示形如2010/7/30的形式&lt;/p&gt;

&lt;p&gt;date +%H:%M 会显示11:35&lt;/p&gt;

&lt;p&gt;2、显示日历：cal&lt;/p&gt;

&lt;p&gt;1）直接输入显示的是当前月份带日历&lt;/p&gt;

&lt;p&gt;2）也可以显示某一年的日历cal 2010,也就是cal ［年］&lt;/p&gt;

&lt;p&gt;3）总带来说cal的语法格式如下：&lt;/p&gt;

&lt;p&gt;cal [month] [year]&lt;/p&gt;

&lt;p&gt;所以还可以显示置顶月份的日历，如 2010年8月的&lt;/p&gt;

&lt;p&gt;cal  2010&lt;/p&gt;

&lt;p&gt;3、简单的计算器：bc&lt;/p&gt;

&lt;p&gt;在输入bc后会显示版本号，然后就可以输入相应的指令了。&lt;/p&gt;

&lt;p&gt;运算符： 除了加减乘除以外，还有^指数，%余数运算。&lt;/p&gt;

&lt;p&gt;》但在默认时，是不保留小数位的，想要保留小数位，需要输入命令scale=number以指定小数位数。&lt;/p&gt;

&lt;p&gt;4、Tab 按键&lt;/p&gt;

&lt;p&gt;不用多说，这事Linxu最棒带功能之一。具有［命令补全］和［档案补全］的功能。可以避免我们打错指令或文件名称！&lt;/p&gt;

&lt;p&gt;5、Ctrl + c 组合键&lt;/p&gt;

&lt;p&gt;如果输入错误的指令或参数，有时候这个指令或程序会在系统下一直不停的运行。这时可以这个组合键以“中断目前程序”。&lt;/p&gt;

&lt;p&gt;6、Ctrl + d 组合键。&lt;/p&gt;

&lt;p&gt;这个组合键有“End of File，EOF”或“End of Input”的意思。 即［键盘输入结束］。相当于‘exit’。&lt;/p&gt;

&lt;p&gt;如想退出终端就可以直接按此组合键。&lt;/p&gt;

&lt;h4 id=&quot;linux&quot;&gt;三、linux图形界面切换到字符界面&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;X-Window图形界面和字符界面自由切换&lt;/p&gt;

    &lt;p&gt;一、图形界面切换到字符界面&lt;/p&gt;

    &lt;p&gt;①在X-Window图形操作界面中按“Alt+Ctrl+Fn（n=1~6）”就可以进入Console字符操作界面。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这就意味着你可以同时拥有X-Window加上6个Console字符操作界面。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;②如果不行，就加上Backspace键：（同时按住Alt+Ctrl，在按一下Backspace并松开，再按Fn）&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在X-Window图形操作界面中按“Alt&amp;amp;#43;Ctrl&amp;amp;#43;Backspace&amp;amp;#43;Fn（n=1~6）”就可以进入Console字符操作界面。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;二、字符界面切换到图像界面&lt;/p&gt;

    &lt;p&gt;①按“Alt+Ctrl+F7”或者“Alt+Ctrl+Backspace+F7”即可。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  这时Linux默认打开7个屏幕，编号为tty1~tty7。X-Window启动后，占用的是tty7号屏幕，tty1~tty6仍为字符界面屏幕。也就是说，用“Alt&amp;amp;#43;Ctrl&amp;amp;#43;Fn”组合键即可实现字符界面与X Window界面的快速切换。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.开机进入字符界面设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;为了在Linux开机启动时直接进入Console字符界面，我们可以编辑/etc/inittab文件。

找到id:5: initdefault:这一行，将它改为id:3:initdefault:后重新启动系统即可。

我们看到，简简单单地将5改为3，就能实现启动时进入X-Window图形操作界面或Console字符界面的转换，这是因为Linux操作系统有六种不同的运行级（run level），在不同的运行级下，系统有着不同的状态，这六种运行级分别为：

  0 ：停机（记住不要把initdefault 设置为0，因为这样会使Linux无法启动 ）

 1：单用户模式，就像Win9X下的安全模式。

 2：多用户，但是没有 NFS 。

 3：完全多用户模式，标准的运行级。

 4：一般不用，在一些特殊情况下可以用它来做一些事情。

 5：X11，即进到 X-Window 系统。

 6：重新启动 （记住不要把initdefault 设置为6，因为这样会使Linux不断地重新启动）。


 其中运行级3就是我们要进入的标准Console字符界面模式。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;linux-1&quot;&gt;四、Linux终端字符界面显示乱码解决方法&lt;/h4&gt;

&lt;p&gt;方法一：配置SSH工具&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SecureCRT中文版配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[全局选项]→[默认会话]→[编辑默认设置]→[终端]→[外观]→[字体]→[新宋体 10pt CHINESE_GB2312]→[字符编码 UTF-8]&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Putty配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[window]→[Appearance]→[Font settings]→[Change]→[Fixedsys CHINESE_GB2312]&lt;/p&gt;

&lt;p&gt;[window]→[Appearance]→[Translation]→[Received data assumed to be in which character set]→[Use font encoding UTF-8]&lt;/p&gt;

&lt;p&gt;如果经常使用,把这些设置保存在session里面。&lt;/p&gt;

&lt;p&gt;打开putty，登录成功后，在shell中输入:export LC_ALL=’zh_CN.utf8’&lt;/p&gt;

&lt;p&gt;方法二：配置系统&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;console终端乱码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在/etc/profile文件的最后一行添加如下内容：&lt;/p&gt;

&lt;p&gt;export LC_ALL=”zh_CN.GB18030”&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;xwindow终端乱码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在/etc/sysconfig/i18n文件的最后一行添加如下内容：&lt;/p&gt;

&lt;p&gt;export LC_ALL=”zh_CN.GB18030”&lt;/p&gt;

&lt;p&gt;vi /etc/sysconfig/i18n&lt;/p&gt;

&lt;p&gt;将内容改为&lt;/p&gt;

&lt;p&gt;LANG=”zh_CN.GB18030”&lt;/p&gt;

&lt;p&gt;LANGUAGE=”zh_CN.GB18030:zh_CN.GB2312:zh_CN”&lt;/p&gt;

&lt;p&gt;SUPPORTED=”zh_CN.GB18030:zh_CN:zh:en_US.UTF-8:en_US:en”&lt;/p&gt;

&lt;p&gt;SYSFONT=”lat0-sun16”&lt;/p&gt;

&lt;p&gt;之后重启机器，这样中文在SSH,telnet终端就可以正常显示了。&lt;/p&gt;

&lt;p&gt;注意：若操作系统语言是英文，显示中文字符为乱码时&lt;/p&gt;

&lt;p&gt;编辑/etc/sysconfig/i18n，修改为如下内容：&lt;/p&gt;

&lt;p&gt;LANG=”en_US”&lt;/p&gt;

&lt;p&gt;SUPPORTED=”en_US.UTF-8:en_US:en”&lt;/p&gt;

&lt;p&gt;SYSFONT=”latarcyrheb-sun16”&lt;/p&gt;
</content>
<category term="ubuntu" />
<summary>一、快捷键</summary>
</entry>
<entry>
<title>pip requirements</title>
<link href="http://localhost:4000/pip-requirements/" rel="alternate" type="text/html" title="pip requirements" />
<published>2017-02-19T18:32:00+08:00</published>
<updated>2017-02-19T18:32:00+08:00</updated>
<id>http://localhost:4000/pip-requirements</id>
<content type="html" xml:base="http://localhost:4000/pip-requirements/">&lt;h1 id=&quot;requirementstxt&quot;&gt;如何自动生成和安装requirements.txt依赖&lt;/h1&gt;

&lt;p&gt;在查看别人的Python项目时，经常会看到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;requirements.txt&lt;/code&gt;文件，里面记录了当前程序的所有依赖包及其精确版本号。这个文件有点类似与Rails的&lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt;。其作用是用来在另一台PC上重新构建项目所需要的运行环境依赖。&lt;/p&gt;

&lt;p&gt;requirements.txt可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt;命令自动生成和安装&lt;/p&gt;

&lt;h3 id=&quot;requirementstxt-1&quot;&gt;生成requirements.txt文件&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;requirementstxt-2&quot;&gt;安装requirements.txt依赖&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pip install -r requirements.txt&lt;/code&gt;&lt;/p&gt;
</content>
<category term="python" />
<category term="pip" />
<summary>如何自动生成和安装requirements.txt依赖</summary>
</entry>
<entry>
<title>shadowsocks锐速</title>
<link href="http://localhost:4000/shadowsocks%E9%94%90%E9%80%9F/" rel="alternate" type="text/html" title="shadowsocks锐速" />
<published>2017-02-18T21:35:00+08:00</published>
<updated>2017-02-18T21:35:00+08:00</updated>
<id>http://localhost:4000/shadowsocks锐速</id>
<content type="html" xml:base="http://localhost:4000/shadowsocks%E9%94%90%E9%80%9F/">&lt;h2 id=&quot;section&quot;&gt;更换内核&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-3.10.0-229.1.2.el7.x86_64.rpm --force
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;锐速加速&lt;/h2&gt;

&lt;p&gt;查看&lt;a href=&quot;https://www.91yun.org/wp-content/plugins/91yun-serverspeeder/systemlist.html&quot;&gt;linux支持内核列表&lt;/a&gt;**&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;uname -a&lt;/code&gt;命令来查询内核版本，例如返回的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux ss 3.8.0-35-generic&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;3.8.0-35-generic&lt;/code&gt;就是内核版本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这里顺便说一下linode VPS仅支持debian7系统，在选择内核时请选择3.14.5-x86_64-linode42版本，这个版本才能安装锐速。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后检查你的VPS是什么虚拟化技术，锐速不支持OpenVZ的（而大部分很便宜的VPS都是OpenVZ）&lt;/p&gt;

&lt;p&gt;我们只需要安装&lt;strong&gt;vitr-what&lt;/strong&gt;就能知道VPS的虚拟化技术是什么了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cent OS 系统：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install virt-what -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Debian/Ubuntu 系统：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install virt-what -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装后执行下面这个命令，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;virt-what
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行后会显示你的VPS虚拟化技术，如果不是OpenVZ，那么可以继续下面的安装步骤了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;安装开心版锐速&lt;/h2&gt;

&lt;p&gt;确定自己的内核版本在支持列表里，并且虚拟化技术非OpenVZ，就可以使用以下命令一键安装了。&lt;/p&gt;

&lt;p&gt;为了备份和存档，这里我收集了几个锐速开心版的一键安装脚本，&lt;strong&gt;大家优先使用第一个脚本！&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;amp;&amp;amp; bash serverspeeder-all.sh
# 注意！！建议使用第一个代码来安装，下面的几个都是备用的，功能都一样，不需要重复执行，只需要执行第一行代码就行了，每一行代码都是独立的。
————
curl -s http://f.ylnote.com/f/install -o install;chmod 775 install;./install
wget -O - http://file.idc.wiki/get.php?serverSpeeder | bash &amp;amp;&amp;amp; bash serverSpeeder_setup.sh
————
# 上面三个不区分系统。下面这四个区分系统
————
# Debian7 64位
wget o0o.re/rs&amp;amp;&amp;amp;sh rs
# Centos6 64位
wget o0o.re/rscentos&amp;amp;&amp;amp;sh rscentos
# centos7 64位
wget o0o.re/rscentos7&amp;amp;&amp;amp;sh rscentos7
# Ubuntu14 64位
wget o0o.re/rsu&amp;amp;&amp;amp;sh rsu
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本会自动检测你的VPS是否可以按照开心版锐速，如果可以就会提示你参数或者直接安装完成，参数设置直接回车默认即可。&lt;/p&gt;

&lt;p&gt;最后两项输入&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;开机自动启动锐速，&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;立刻启动锐速。（这个参数设置一般情况下都是不会出现的。）&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;https://doub.io/wp-content/plugins/wp-images-lazy-loading/images/grey.gif&quot; alt=&quot;&quot; /&gt;![](https://img.mlkxs.com/ruisu-jc1.1.jpg?imageView2/1/w/2000/q/100&lt;/td&gt;
      &lt;td&gt;watermark/1/image/aHR0cDovLzd4ajh0NC5jb20xLnowLmdsYi5jbG91ZGRuLmNvbS9zaHVpeWluLnBuZw==/dissolve/80/gravity/SouthEast/dx/10/dy/10)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-3&quot;&gt;卸载开心版锐速&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chattr -i /serverspeeder/etc/apx* &amp;amp;&amp;amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;锐速开心版功能：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;如果内核完全匹配就会自动下载安装。&lt;/li&gt;
  &lt;li&gt;如果没有完全匹配的内核，会在界面提示可选内核，可以手动选个最接近的尝试&lt;/li&gt;
  &lt;li&gt;自动下载授权文件&lt;/li&gt;
  &lt;li&gt;自动修改配置文件&lt;/li&gt;
  &lt;li&gt;已chattr +i /serverspeeder/etc/apx*禁止修改配置文件，可以不用加hosts了&lt;/li&gt;
  &lt;li&gt;目前只支持CentOS，ubuntu和debian。如果有其他系统支持，可以到http://www.91yun.org/serverspeeder91yun手动下载其他系统的安装包&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;开启高级算法&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Tip：开心版锐速默认都启动高级算法了，所以可以忽略下面的步骤。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一些KVM/XEN的VPS上支持高级算法，所以我们可以修改锐速的3个参数来开启，&lt;code class=&quot;highlighter-rouge&quot;&gt;vi /serverspeeder/etc/config&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rsc=&quot;1&quot; #RSC网卡驱动模式  
gso=&quot;1&quot;
maxmode=&quot;1&quot; #最大传输模式
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;使用命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#重启锐速
/serverspeeder/bin/serverSpeeder.sh restart
#启动锐速
/serverspeeder/bin/serverSpeeder.sh start
#停止锐速
/serverspeeder/bin/serverSpeeder.sh stop
#查看锐速运行情况
/serverspeeder/bin/serverSpeeder.sh status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-7&quot;&gt;删除锐速&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#脚本删除，如果不行就用下面的强制删除
./serverSpeederInstaller.sh uninstall
强制删除
rm -rf /serverspeeder
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;第一个开心版锐速脚本来自：&lt;a href=&quot;https://www.91yun.org/archives/683&quot;&gt;https://www.91yun.org/archives/683&lt;/a&gt;&lt;/p&gt;
</content>
<category term="shadowsocks" />
<summary>更换内核</summary>
</entry>
<entry>
<title>flask框架5</title>
<link href="http://localhost:4000/flask%E6%A1%86%E6%9E%B65/" rel="alternate" type="text/html" title="flask框架5" />
<published>2017-02-12T15:37:00+08:00</published>
<updated>2017-02-12T15:37:00+08:00</updated>
<id>http://localhost:4000/flask框架5</id>
<content type="html" xml:base="http://localhost:4000/flask%E6%A1%86%E6%9E%B65/">&lt;h2 id=&quot;flask&quot;&gt;动态基于用户的内容Flask教程&lt;/h2&gt;

&lt;p&gt;虽然我们可以使用装饰器来包围访问控制的函数，但我们也可以使用我们的Jinja模板逻辑来控制视图。例如，现在，当我们登录我们的网站时，我们仍然在右上角有一个“登录”按钮。&lt;/p&gt;

&lt;p&gt;我们应该真的让登录按钮消失，与注册按钮一样，然后添加一个“注销”按钮。&lt;/p&gt;

&lt;p&gt;我们实际上可以在我们的HTML文件中处理所有这些，所以让我们访问我们的header.html文件。&lt;/p&gt;

&lt;p&gt;找到与navbar相关联的代码，然后替换为一些逻辑：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	  &amp;lt;ul class=&quot;nav navbar-nav navbar-right&quot;&amp;gt;
		    &amp;lt;div style=&quot;margin-right: 10px; margin-left: 15px; margin-top: 5px; margin-bottom: 5px;&quot;  class=&quot;container-fluid&quot;&amp;gt;
			&amp;lt;h5&amp;gt;
				&amp;amp;#123;% if session.logged_in %}
				&amp;lt;a href=&quot;/support-donate/&quot;&amp;gt; &amp;lt;span class=&quot;glyphicon glyphicon-heart&quot;&amp;gt;&amp;lt;/span&amp;gt; Support   &amp;lt;/a&amp;gt;
				&amp;lt;a href=&quot;/logout/&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-log-out&quot;&amp;gt;&amp;lt;/span&amp;gt; Logout   &amp;lt;/a&amp;gt;
				&amp;amp;#123;% else %}
				&amp;lt;a href=&quot;/support-donate/&quot;&amp;gt; &amp;lt;span class=&quot;glyphicon glyphicon-heart&quot;&amp;gt;&amp;lt;/span&amp;gt; Support   &amp;lt;/a&amp;gt;
				&amp;lt;a href=&quot;/login/&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-log-in&quot;&amp;gt;&amp;lt;/span&amp;gt; Login   &amp;lt;/a&amp;gt;
				&amp;lt;a href=&quot;/register/&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-pencil&quot;&amp;gt;&amp;lt;/span&amp;gt; Sign up&amp;lt;/a&amp;gt;
				&amp;amp;#123;% endif %}
			&amp;lt;/div&amp;gt;

			&amp;lt;/h5&amp;gt;
		  &amp;lt;/div&amp;gt;
      &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的两件事：我们显然能够引用会话，我们不需要在我们的模板中“导入”它。这样的逻辑在你的HTML可以抛出一个循环的默认标签识别/突出显示！&lt;/p&gt;

&lt;p&gt;Jinja模板基本上有一个“从烧瓶进口*”在幕后。您可以在模板中引用任何Flask内容，而无需将其导入模板或脚本。&lt;/p&gt;

&lt;p&gt;当你构建这样的HTML逻辑，特别是当它影响用户看到什么，你可能会发现它破坏了自然的突出显示，你的编辑器可能会标记的东西，如标签没有关闭等。使用你更好的判断。有时，如果内容足够厚，并且是一种if / else类似上面，我将删除每个块，一次一个，并检查以确保一切连接正确。&lt;/p&gt;

&lt;p&gt;不管什么，但是，它可以是混乱。注意它，特别是如果你让你的编辑器自动关闭或移动标签。&lt;/p&gt;
</content>
<category term="flask" />
<summary>动态基于用户的内容Flask教程</summary>
</entry>
<entry>
<title>flask框架4</title>
<link href="http://localhost:4000/flask%E6%A1%86%E6%9E%B64/" rel="alternate" type="text/html" title="flask框架4" />
<published>2017-02-12T15:36:00+08:00</published>
<updated>2017-02-12T15:36:00+08:00</updated>
<id>http://localhost:4000/flask框架4</id>
<content type="html" xml:base="http://localhost:4000/flask%E6%A1%86%E6%9E%B64/">&lt;h2 id=&quot;flask---loginrequiredflask&quot;&gt;Flask装饰器 - Login_Required页面Flask教程&lt;/h2&gt;

&lt;p&gt;现在我们可以让用户注册和登录，我们也允许他们注销。这是有一点意义，不让用户注销，除非他们登录！&lt;/p&gt;

&lt;p&gt;您还可能会发现您想要保护各种页面，例如管理页面，或者您有订阅者内容或其他受保护或付费内容。&lt;/p&gt;

&lt;p&gt;你可以使用包装函数。人们倾向于避开包装函数和装饰器，因为它们可能是混乱的。但是，看看你，你一直在使用他们这一次！Flask使用它们进行URL路由。让我们展示如何使我们自己的！这其实很简单！&lt;/p&gt;

&lt;p&gt;首先，我们向我们的__init__.py文件添加一个login_required函数：&lt;/p&gt;

&lt;p&gt;{% highlight css %}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def login_required(f):
    @wraps(f)
    def wrap( *args, **kwargs):
        if 'logged_in' in session:
            return f(*args, **kwargs)
        else:
            flash(&quot;You need to login first&quot;)
            return redirect(url_for('login_page'))

    return wrap {% endhighlight %}    		
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里，我们定义函数，其中参数是f，这是约定的事实，它包装一个函数。然后，我们定义包装器。&lt;/p&gt;

&lt;p&gt;我们的包装器很简单，只是简单地检查用户在会话中是否有“logged_in”。如果是这样，伟大。如果没有，他们会收到一条Flash消息和重定向到登录页面。&lt;/p&gt;

&lt;p&gt;现在我们有了包装器函数，我们准备好将它应用到任何我们想要的登录。例如，我们可以将其应用于我们的注销页面，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.route(&quot;/logout/&quot;)
@login_required
def logout():
    session.clear()
    flash(&quot;You have been logged out!&quot;)
    gc.collect()
    return redirect(url_for('dashboard'))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很简单，在app.route包装器的下面，我们还添加了另一个包装器，它是login_required包装器。现在，为了甚至得到注销函数，用户必须首先尝试访问顶部包装器中的URL，然后他们还需要满足下一个包装器的条件，然后他们可以最终到达logout（）函数！&lt;/p&gt;
</content>
<category term="flask" />
<summary>Flask装饰器 - Login_Required页面Flask教程</summary>
</entry>
</feed>
