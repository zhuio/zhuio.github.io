<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--><!--[if gt IE 8]><!--><html class="no-js">
<!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> <title>kivy文档10 – 朱智博在Github上的Blog</title> <meta name="description" content="朱智博，朱智博的博客，zhuio,zhuio.github.io,"> <meta name="keywords" content="kivy"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="http://localhost:4000/assets/img/logo.png"> <meta name="twitter:title" content="kivy文档10"> <meta name="twitter:description" content="Kivy中文编程指南：KV 语言"> <!-- Open Graph --> <meta property="og:locale" content="zh_CN"> <meta property="og:type" content="article"> <meta property="og:title" content="kivy文档10"> <meta property="og:description" content="Kivy中文编程指南：KV 语言"> <meta property="og:url" content="http://localhost:4000/kivy%E6%96%87%E6%A1%A310/"> <meta property="og:site_name" content="朱智博在Github上的Blog"> <meta property="og:image" content="http://localhost:4000/assets/img/logo.png"> <link rel="canonical" href="http://localhost:4000/kivy%E6%96%87%E6%A1%A310/"> <link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="朱智博在Github上的Blog Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> <!-- JS --> <script src="http://localhost:4000/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="http://localhost:4000/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="http://localhost:4000/favicon.png"> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico"> <!-- Background Image --> <style type="text/css">body {background-image:url(http://localhost:4000/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="http://localhost:4000/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="http://localhost:4000/assets/img/logo.png" alt="朱智博在Github上的Blog photo" class="author-photo"> <h4>朱智博在Github上的Blog</h4> <p>朱智博，朱智博的博客，zhuio,zhuio.github.io,</p> </li> <li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:185560083@qq.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/zhuio" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> <li> <a href="http://www.weibo.com/EDM_LOVER" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-weibo"></i> Weibo</a> </li> </ul>
<!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="http://localhost:4000/posts/">All Posts</a></li> <li><a href="http://localhost:4000/tags/">All Tags</a></li> </ul> </li> <li><a href="http://localhost:4000/projects/">Projects</a></li> </ul>
<!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn"> <div class="content"> <div class="post-title "> <h1>kivy文档10</h1> <h4>07 Aug 2017</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> Reading time ~4 minutes </p>
<!-- /.entry-reading-time --> <a class="btn zoombtn" href="http://localhost:4000/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <h1 id="kivy中文编程指南kv-语言">Kivy中文编程指南：KV 语言</h1> <p><a href="https://kivy.org/docs/guide/lang.html">英文原文</a></p> <h2 id="语言背后的概念">语言背后的概念</h2> <p>随着你的应用程序越写越复杂，就往往会发现控件树的结构/各种绑定的声明等等，都越来越繁琐复杂了，维护起来也很费力气。KV 语言就是为了解决这个问题而设计出来的。</p> <p>（译者注：这种情况在 GUI 界面的 APP 开发中很常见，比如在 Android 开发的过程中，就用到了 xml 来定义界面元素的关系等等。）</p> <p>KV 语言（英文缩写也叫 kvlang 或者 kivy 语言），可以让开发者用描述的方式来创建控件树，以及绑定控件对应的属性，以实现一种自然地调用。这一设计可以允许用户能够快速建立应用雏形，然后对界面进行灵活调整。此外，这样的设计还使得运行逻辑与用户界面相互分离不干扰。</p> <h2 id="载入-kv-的方法">载入 KV 的方法</h2> <p>通过以下两种方法都可以在你的应用程序中载入 KV 代码：</p> <ul> <li> <p>通过同名文件查找： Kivy 会找跟 App 类同名的小写字母的 Kv 扩展名的文件，如果你的应用类尾部有 App 字样，查找的时候会找去掉这个 App 字样的文件，例如： MyApp -&gt; my.kv 如果这个文件定义了一个根控件，这个文件就会被添加到应用的根属性中去，然后用作整个程序的控件树基础。</p> </li> <li> <p><code class="highlighter-rouge">Builder</code>: 也可以直接指定让 Kivy 去加载某个字符串或者文件。如果这个字符串或者文件定义了一个根控件，就会被下面这个方法返回： <code class="highlighter-rouge">Builder.load_file('path/to/file.kv')</code>或者<code class="highlighter-rouge">Builder.load_string(kv_string)</code></p> </li> </ul> <h2 id="规则语义">规则语义</h2> <p>Kv 源文件包含有各种规则，这些规则是用来描述控件的环境设定的，可以有一个根规则，然后其他的各种类的或者模板的规则就都不限制数量来。</p> <p>根规则是用来描述你的根控件类的，不能有任何缩进，跟着一个英文冒号:，在应用程序的实例当中这就会被设置成根属性：</p> <p><code class="highlighter-rouge">Widget:</code></p> <p>一类规则，声明方式为将控件类的名字用尖括号括起来的，然后跟着一个英文冒号:，这类规则用来定义这个类的实例图形化呈现的方式：</p> <p><code class="highlighter-rouge">&lt;MyWidget&gt;:</code></p> <p>Kv 文件中各种规则都用缩进来进行区块划分，就像 Python 里面一样，这些缩进得是四个空格作为一层缩进，就跟 Python 里面推荐的做法是一样的。</p> <p>以下是三个 Kv 语言的关键词：</p> <ul> <li>app: 指向你应用程序的实例。</li> <li>root: 指向当前规则中的基础控件或者基础模板。</li> <li>self: 指向当前的控件。</li> </ul> <h2 id="特殊语法">特殊语法</h2> <p>有两种特殊的语法，能定义整个 Kv 环境下的各种值：</p> <p>读取 Kv 中的 Python 模块和各种类：</p>
<pre><code class="language-Python">#:import name x.y.z
#:import isdir os.path.isdir
#:import np numpy
</code></pre>
<p>等价于 Python 中的：</p>
<pre><code class="language-Python">from x.y import z as name
from os.path import isdir
import numpy as np
</code></pre>
<p>设置各种全局变量：</p>
<pre><code class="language-Python">#:set name value
</code></pre>
<p>等价于 Python 中的：</p>
<pre><code class="language-Python">name = value
</code></pre>
<h2 id="子对象实例化">子对象实例化</h2> <p>To declare the widget has a child widget, instance of some class, just declare this child inside the rule:</p> <p>给一个控件声明子控件，比如某个类的实例，只要在规则内部声明一下这个子对象就可以类：</p>
<pre><code class="language-Python">MyRootWidget:
    BoxLayout:
        Button:
        Button:
</code></pre>
<p>上面的样例代码定义了根控件，是一个 MyRootWidget 的实例，它有一个子控件，是一个 <a href="https://kivy.org/docs/api-kivy.uix.boxlayout.html"><code class="highlighter-rouge">BoxLayout</code></a> 实例。这个 <a href="https://kivy.org/docs/api-kivy.uix.boxlayout.html"><code class="highlighter-rouge">BoxLayout</code></a> 还有自己的两个子对向，是两个 <a href="https://kivy.org/docs/api-kivy.uix.button.html"><code class="highlighter-rouge">Button</code></a> 类的实例。</p> <p>与上面代码等价的 Python 代码大致如下：</p>
<pre><code class="language-Python">root = MyRootWidget()
box = BoxLayout()
box.add_widget(Button())
box.add_widget(Button())
root.add_widget(box)
</code></pre>
<p>你可能会发现直接用 Python 来实现的代码不那么好阅读，写起来也不那么简便。</p> <p>用 Python 可以在创建控件的时候传递关键词参数过去，来指定这些控件的行为。例如下面的这个代码就是设定一个 <a href="https://kivy.org/docs/api-kivy.uix.gridlayout.html"><code class="highlighter-rouge">gridlayout</code></a> 中的栏目数：</p>
<pre><code class="language-Python">grid = GridLayout(cols=3)
</code></pre>
<p>同样目的也可以用 Kv 来实现，可以直接在规则内指定好子控件的属性：</p>
<pre><code class="language-Python">GridLayout:
    cols: 3
</code></pre>
<p>这个值会作为一个 Python 表达式来进行计算，然后所有在表达式中用到的属性都是可见的，就好比下面的 Python 代码一样（这里假设 self 是一个有 <code class="highlighter-rouge">ListProperty</code> 数据的控件）：</p>
<pre><code class="language-Python">grid = GridLayout(cols=len(self.data))
self.bind(data=grid.setter('cols'))
</code></pre>
<p>如果想要在数据修改的时候就更新显示，可以用如下方法实现：</p>
<pre><code class="language-Python">GridLayout:
    cols: len(root.data)
</code></pre>
<h4 id="特别注意">特别注意</h4> <p>控件的名字一定要用大写字母打头，而属性的名字一定要用小写的。推荐遵循<a href="https://www.python.org/dev/peps/pep-0008/#naming-conventions">PEP8 命名惯例</a>。</p> <h2 id="事件绑定">事件绑定</h2> <p>在 Kv 中，使用英文冒号 “:” 就可以来进行事件绑定，也就是将某个回调和一个事件联系起来：</p>
<pre><code class="language-Python">Widget:
    on_size: my_callback()
</code></pre>
<p>使用 args 关键词的信号，就能把分派来的值传递过去类：</p>
<pre><code class="language-Python">TextInput:
    on_text: app.search(args[1])
</code></pre>
<p>还可以用更加复杂的表达式，例如：</p>
<pre><code class="language-Python">pos: self.center_x - self.texture_size[0] / 2., self.center_y - self.texture_size[1] / 2.
</code></pre>
<p>上面这段表达式中，监听了<code class="highlighter-rouge">center_x</code>, <code class="highlighter-rouge">center_y</code>, <code class="highlighter-rouge">texture_size</code>这三个属性的变化。只要其中有一个发生了变化，表达式就会重新计算来更新 <code class="highlighter-rouge">pos</code> 的区域。</p> <p>你还看以在 kv 语言中处理 <code class="highlighter-rouge">on_</code> 事件。例如 TextInput 这个类就有一个 <code class="highlighter-rouge">focus</code> 属性，这个数行自动生成的 <code class="highlighter-rouge">on_focus</code> 事件可在 kv 语言内进行读取：</p>
<pre><code class="language-Python">TextInput:
    on_focus: print(args)
</code></pre>
<h2 id="扩展画布">扩展画布</h2> <p>Kv 语言也已用来定义你控件的画布，如下所示：</p>
<pre><code class="language-Python">MyWidget:
    canvas:
        Color:
            rgba: 1, .3, .8, .5
        Line:
            points: zip(self.data.x, self.data.y)
</code></pre>
<p>当属性发生变化的时候，这些画布就会更新。当然也可以用 canvas.before 和 canvas.after。</p> <h2 id="定位控件">定位控件</h2> <p>在一个控件树当中，经常会需要去读取或者定位其他的控件。 Kv 语言提供了一种快速的方法来实现这一目的，就是使用 id。（译者注：在 Android 的开发中就是这样的。） 可以把这些控件当作是类这以层次的变量，只能在 Kv 语言中使用。例如下面的：</p>
<pre><code class="language-Python">&lt;MyFirstWidget&gt;:
    Button:
        id: f_but
    TextInput:
        text: f_but.state

&lt;MySecondWidget&gt;:
    Button:
        id: s_but
    TextInput:
        text: s_but.state
</code></pre>
<p>An <code class="highlighter-rouge">id</code> is limited in scope to the rule it is declared in, so in the code above <code class="highlighter-rouge">s_but</code> can not be accessed outside the <code class="highlighter-rouge">&lt;MySecondWidget&gt;</code> rule.</p> <p><code class="highlighter-rouge">id</code> 只能再所处的规则内使用，也就是声明它的位置，所以在上面的代码中，<code class="highlighter-rouge">s_but</code> 就不能在 <code class="highlighter-rouge">&lt;MySecondWidget&gt;</code> 规则外被读取到。</p> <h4 id="特别注意-1">特别注意</h4> <p>给一个 <code class="highlighter-rouge">id</code> 赋值的时候，一定要记住这个值不能是字符串。所以不能有引号：这是正确的 -&gt; <code class="highlighter-rouge">id: value</code>, 这样就不对 -&gt; <code class="highlighter-rouge">id: 'value'</code> <code class="highlighter-rouge">id</code> 是对空间的一个 <code class="highlighter-rouge">weakref</code> （弱引用），而不是控件本身。所以，在垃圾回收的时候要保存控件，就不能仅仅保存 <code class="highlighter-rouge">id</code>。</p> <p>下面的代码中：</p>
<pre><code class="language-Python">&lt;MyWidget&gt;:
    label_widget: label_widget
    Button:
        text: 'Add Button'
        on_press: root.add_widget(label_widget)
    Button:
        text: 'Remove Button'
        on_press: root.remove_widget(label_widget)
    Label:
        id: label_widget
        text: 'widget'
</code></pre>
<p>虽然 <code class="highlighter-rouge">MyWidget</code> 中已经存储了一个对 <code class="highlighter-rouge">label_widget</code> 的引用，但是这个只是一个弱引用，其他引用被移除的时候还不足以保证对象依然可用。因此，在移除按钮被点击（这时候也就是移除类所有对这个控件的引用）之后，或者窗口大小被调整了（这会调用垃圾回收器，导致删掉 <code class="highlighter-rouge">label_widget</code>），这时候如果点击添加按钮来重新把控件增加回来的话，就会有一个引用错误(<code class="highlighter-rouge">ReferenceError</code>)被抛出来：因为弱引用的对象已经不存在类。</p>
<pre><code class="language-Python">&lt;MyWidget&gt;:
    label_widget: label_widget.__self__
</code></pre>
<h2 id="python-代码读取在-kv-中定义的控件">Python 代码读取在 Kv 中定义的控件</h2> <p>假如在 my.kv 文件中有如下的代码：</p>
<pre><code class="language-Python">&lt;MyFirstWidget&gt;::
    # both these variables can be the same name and this doesn't lead to
    # an issue with uniqueness as the id is only accessible in kv.
    txt_inpt: txt_inpt
    Button:
        id: f_but
    TextInput:
        id: txt_inpt
        text: f_but.state
        on_text: root.check_status(f_but)
</code></pre>
<p>在 myapp.py 这个文件中：</p>
<pre><code class="language-Python">...
class MyFirstWidget(BoxLayout):

    txt_inpt = ObjectProperty(None)

    def check_status(self, btn):
        print('button state is: {state}'.format(state=btn.state))
        print('text input text is: {txt}'.format(txt=self.txt_inpt))
...
</code></pre>
<p>txt_inpt 是一个<a href="https://kivy.org/docs/api-kivy.properties.html#kivy.properties.ObjectProperty" title="kivy.properties.ObjectProperty"><code class="highlighter-rouge">ObjectProperty</code></a>对象，在类内被初始化为 None。</p>
<pre><code class="language-Python">txt_inpt = ObjectProperty(None)
</code></pre>
<p>目前位置，这个 self.txt_inpt 还是 None。在 Kv 语言中，这个属性会进行更新，保存 txt_input 这个 id 所引用的 <code class="highlighter-rouge">TextInput</code> 实例：</p>
<pre><code class="language-Python">txt_inpt: txt_inpt
</code></pre>
<p>从这以后，self.txt_inpt 久保存了一个到控件的引用，通过 txt_input 这个 id 来识别，可以在类内的各个地方来使用，就跟在 check_status 函数里一样。当然也可以不这么做，可以把 id 传给需要用到它的函数，例如上面代码中那个 f_but 这个例子。</p> <p>通过 id 标签，在 kv 语言中可以查找对象，这是一种更简单的读取对象的方法。比如下面这段代码：</p>
<pre><code class="language-Python">&lt;Marvel&gt;
  Label:
    id: loki
    text: 'loki: I AM YOUR GOD!'
  Button:
    id: hulk
    text: "press to smash loki"
    on_release: root.hulk_smash()
</code></pre>
<p>在你的 Python 代码中：</p>
<pre><code class="language-Python">class Marvel(BoxLayout):
    def hulk_smash(self):
        self.ids.hulk.text = "hulk: puny god!"
        self.ids["loki"].text = "loki: &gt;_  # alternative syntax
</code></pre>
<p>当你的 kv 文件被解析的时候，kivy 会选中所有带有标签 id 的控件，然后把它们放到 self.ids 这样一个辞典类型的属性里面去。所以你就可以对这些控件进行遍历，然后像是辞典数据一样来进行读取类：</p>
<pre><code class="language-Python">for key, val in self.ids.items():
    print("key={0}, val={1}".format(key, val))
</code></pre>
<h4 id="特别注意-2">特别注意</h4> <p>虽然这种 self.ids 方法非常简便，但通常最推荐的还是用对象属性。这样会创建一个直接的引用，能提供更快地读取速度，并且也更加准确可靠。</p> <h2 id="动态类型">动态类型</h2> <p>参考下面的代码：</p>
<pre><code class="language-Python">&lt;MyWidget&gt;:
    Button:
        text: "Hello world, watch this text wrap inside the button"
        text_size: self.size
        font_size: '25sp'
        markup: True
    Button:
        text: "Even absolute is relative to itself"
        text_size: self.size
        font_size: '25sp'
        markup: True
    Button:
        text: "Repeating the same thing over and over in a comp = fail"
        text_size: self.size
        font_size: '25sp'
        markup: True
    Button:
</code></pre>
<p>如果这里使用一个模板，就不用那么麻烦地去重复对每一个按钮进行设置了，例如下面这样就可以了：</p>
<pre><code class="language-Python">&lt;MyBigButt@Button&gt;:
    text_size: self.size
    font_size: '25sp'
    markup: True

&lt;MyWidget&gt;:
    MyBigButt:
        text: "Hello world, watch this text wrap inside the button"
    MyBigButt:
        text: "Even absolute is relative to itself"
    MyBigButt:
        text: "repeating the same thing over and over in a comp = fail"
    MyBigButt:
</code></pre>
<p>上面这个类是在这个规则的声明内建立的，继承了按钮类 Button，然后我们就可以用这个类来对默认值进行修改，并且建立所有实例的链接绑定，而不用在 Python 弄一大堆新代码了。</p> <h2 id="在多个控件中复用样式">在多个控件中复用样式</h2> <p>参考下面的代码，在 my.kv 文件中：</p>
<pre><code class="language-Python">&lt;MyFirstWidget&gt;:
    Button:
        on_press: root.text(txt_inpt.text)
    TextInput:
        id: txt_inpt

&lt;MySecondWidget&gt;:
    Button:
        on_press: root.text(txt_inpt.text)
    TextInput:
        id: txt_inpt
</code></pre>
<p>在 myapp.py 这个文件中：</p>
<pre><code class="language-Python">class MyFirstWidget(BoxLayout):
    def text(self, val):
        print('text input text is: {txt}'.format(txt=val))

class MySecondWidget(BoxLayout):
    writing = StringProperty('')
    def text(self, val):
        self.writing = val
</code></pre>
<p>好多类都要用到同样的 .kv 样式文件，这样就可以通过让所有控件都对样式进行复用，就能简化一下设计。这就可以在 kv文件中来实现。例如下面这个就是 my.kv 文件中的代码：</p>
<pre><code class="language-Python">&lt;MyFirstWidget,MySecondWidget&gt;:
    Button:
        on_press: self.text(txt_inpt.text)
    TextInput:
        id: txt_inpt
</code></pre>
<p>只要把各个类的名字用英文冒号:分隔开，声明当中包含的类就都会使用相同的 kv 属性了。</p> <h2 id="使用-kivy-语言来设计">使用 Kivy 语言来设计</h2> <p>Kivy 语言的设计目标之一就是希望能够<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">做好分工</a>，把界面和内部逻辑相互分离。输出的样式由你的 kv 文件来确定，运行逻辑靠你的 python 代码来执行。</p> <h3 id="python-文件中的代码">Python 文件中的代码</h3> <p>来一个简单的小例子。首先要有一个名字为 main.py 的 Python 源文件：</p>
<pre><code class="language-Python">import kivy
kivy.require('1.0.5')

from kivy.uix.floatlayout import FloatLayout
from kivy.app import App
from kivy.properties import ObjectProperty, StringProperty

class Controller(FloatLayout):
'''
创建一个控制器，从 kv 文件中接收一个定制的控件。
增加一个由 kv 文件进行调用的动作。
'''
    label_wid = ObjectProperty()
    info = StringProperty()
    def do_action(self):
        self.label_wid.text = 'My label after button press'
        self.info = 'New info text'

class ControllerApp(App):
    def build(self):
        return Controller(info='Hello world')

if __name__ == '__main__':
    ControllerApp().run()
</code></pre>
<p>刚刚这个代码样例中，我们创建了一个有两个属性的控制器：</p> <ul> <li>
<code class="highlighter-rouge">info</code> 该属性用于接收文本</li> <li>
<code class="highlighter-rouge">label_wid</code> 该属性用于接收文本标签控件</li> </ul> <p>此外还创建了一个 <code class="highlighter-rouge">do_action()</code> 方法，这个方法会使用上面的属性。这个方法会改变 <code class="highlighter-rouge">info</code>里面的文本，以及 <code class="highlighter-rouge">label_wid</code> 控件中的文本。</p> <h3 id="controllerkv-文件中的布局样式">controller.kv 文件中的布局样式</h3> <p>没有对应的 kv 文件，应用程序也能运行，只不过是屏幕上不会有任何显示输出。这个是符合情理的，因为毕竟控制器 <code class="highlighter-rouge">Controller</code> 这个类是没有任何控件的，就只是一个<code class="highlighter-rouge">FloatLayout</code>（流动输出？）咱们可以创建一个名字为 controller.kv 的文件，来围绕着这个控制器类 <code class="highlighter-rouge">Controller</code> 搭建 UI （用户界面），这个文件会在运行 <code class="highlighter-rouge">ControllerApp</code> 的时候被加载。这个具体怎么实现的，以及加载类哪些文件，可以参考 <a href="https://kivy.org/docs/api-kivy.app.html#kivy.app.App.load_kv" title="kivy.app.App.load_kv"><code class="highlighter-rouge">kivy.app.App.load_kv()</code></a> 方法里的描述。</p>
<pre><code class="language-Python">#:kivy 1.0
&lt;Controller&gt;:
    label_wid: my_custom_label

    BoxLayout:
        orientation: 'vertical'
        padding: 20

        Button:
            text: 'My controller info is: ' + root.info
            on_press: root.do_action()

        Label:
            id: my_custom_label
            text: 'My label before button press'
</code></pre>
<p>上面的代码中就是一个竖直的箱式布局（BoxLayout）。看着就挺简单的。这个代码主要功能有以下三个：</p> <p>1 使用来自控制器类 Controller 的数据。只要 controller 中的 info 属性发生了改变，表达式 ‘My controller info is: ‘ + root.info 就会自动重新计算，改变按钮（Button)上面的值。</p> <p>2 传递数据给控制器类 Controller。my_custom_label 这个 id 会赋值给 id 为 my_custom_label 的新建文本标签（Label）。此后，使用 label_wid:my_custom_label 中的 my_custom_label 就能得到一个控制器中的 Label 控件实例了。</p> <p>3 在按钮 Button 中使用控制器类 Controller 的 on_press 方法来创建一个自定义回调。 root 和 self 都是保留关键词，任何地方都不可见的。root 代表的是规则中的顶层控件，self 表示的是当前控件。 你可以在当前规则中使用任意的已经声明过的 id， root 和 self 也可以这样来用。比如下面就是在 on_press() 里面使用 root：</p>
<pre><code class="language-Python">Button:
    on_press: root.do_action(); my_custom_label.font_size = 18
</code></pre>
<p>就这么多了。现在当我们再次运行 main.py的时候，controller.kv 就会被加载，然后 Button 按钮和 Label 文本标签就会出现，并且根据触摸事件进行响应了。</p> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="http://localhost:4000/tags/#kivy" title="Pages tagged kivy" class="tag"><span class="term">kivy</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/kivy%E6%96%87%E6%A1%A310/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/kivy%E6%96%87%E6%A1%A310/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=http://localhost:4000/kivy%E6%96%87%E6%A1%A310/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <h101> <!-- 多说评论框 start --> <div class="ds-thread" data-thread-key="" data-title="kivy文档10" data-url="http://localhost:4000"></div> <!-- 多说评论框 end --> <!-- 多说公共JS代码 start (一个网页只需插入一次) --> <script type="text/javascript"> var duoshuoQuery = {short_name:"zhuio"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); </script> <!-- 多说公共JS代码 end --> </h101> </header> <!-- JS --> <script src="http://localhost:4000/assets/js/jquery-1.12.0.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.dlmenu.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.goup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.magnific-popup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.fitvid.min.js"></script> <script src="http://localhost:4000/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'zhuio-github-io'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
